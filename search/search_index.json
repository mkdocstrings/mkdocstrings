{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"mkdocstrings \u00a4 Automatic documentation from sources, for MkDocs. Features Python handler features Requirements Installation Quick usage Features \u00a4 Language agnostic: just like mkdocs , mkdocstrings is written in Python but is language-agnostic. It means you can use it for any language, as long as you implement a handler for it. Currently, we only have a Python handler . Maybe you'd like to contribute another one ? Multiple themes support: each handler can offer multiple themes. Currently, we only offer the Material theme for the Python handler. Cross-references to other objects: mkdocstrings makes it possible to reference other headings from your Markdown files with the classic Markdown syntax: [identifier][] or [title][identifier] . This feature is language agnostic as well: you can cross-reference any heading that appear in your Markdown pages. If the handler for a particular language renders headings for documented objects, you'll be able to reference them! Inline injection in Markdown: instead of generating Markdown files, mkdocstrings allows you to inject documentation anywhere in your Markdown contents. The syntax is simple: ::: identifier followed by a 4-spaces indented YAML block. The identifier and YAML configuration will be passed to the appropriate handler to collect and render documentation. Global and local configuration: each handler can be configured globally in mkdocs.yml , and locally for each \"autodoc\" instruction. Watch source code directories: you can tell mkdocstrings to add directories to be watched by mkdocs when serving the documentation, for auto-reload. Sane defaults: you should be able to just drop the plugin in your configuration and enjoy your auto-generated docs. Python handler features \u00a4 Data collection from source code : collection of the object-tree and the docstrings is done by pytkdocs . The following features are possible thanks to it: Support for type annotations: pytkdocs collects your type annotations and mkdocstrings uses them to display parameters types or return types. Recursive documentation of Python objects: just use the module dotted-path as identifier, and you get the full module docs. You don't need to inject documentation for each class, function, etc. Support for documented attribute: attributes (variables) followed by a docstring (triple-quoted string) will be recognized by pytkdocs in modules, classes and even in __init__ methods. Support for objects properties: pytkdocs detects if a method is a staticmethod , a classmethod , etc., it also detects if a property is read-only or writable, and more! These properties will be displayed next to the object signature by mkdocstrings . Google-style sections support in docstrings: pytkdocs understands Arguments: , Raises: and Returns: sections, and returns structured data for mkdocstrings to render them. Admonition support in docstrings: blocks like Note: or Warning: will be transformed to their admonition equivalent. We do not support nested admonitions in docstrings! Every object has a TOC entry: we render a heading for each object, meaning mkdocs picks them into the Table of Contents, which is nicely display by the Material theme. Thanks to mkdocstrings cross-reference ability, you can even reference other objects within your docstrings, with the classic Markdown syntax: [this object][package.module.object] or directly with [package.module.object][] Source code display: mkdocstrings can add a collapsible div containing the highlighted source code of the Python object. To get an example of what is possible, check mkdocstrings ' own documentation , auto-generated from sources by itself of course, and the following GIF: Roadmap \u00a4 December-January 2020: Proof of Concept. January-March 2020: Refactor. March-April 2020: Test suite for pytkdocs . Bug fixes, enhancements. May-June 2020: Test suite for mkdocstrings itself. Better documentation. Maybe a second handler, just for the fun. Requirements \u00a4 mkdocstrings requires Python 3.6 or above. To install Python 3.6, I recommend using pyenv . # install pyenv git clone https://github.com/pyenv/pyenv ~/.pyenv # setup pyenv (you should also put these three lines in .bashrc or similar) export PATH = \" ${ HOME } /.pyenv/bin: ${ PATH } \" export PYENV_ROOT = \" ${ HOME } /.pyenv\" eval \" $( pyenv init - ) \" # install Python 3.6 pyenv install 3 .6.12 # make it available globally pyenv global system 3 .6.12 This project currently only works with the Material theme of MkDocs. Therefore, it is required that you have it installed. pip install mkdocs-material Installation \u00a4 With pip : python3.6 -m pip install mkdocstrings Quick usage \u00a4 # mkdocs.yml theme : name : \"material\" plugins : - search - mkdocstrings In one of your markdown files: # Reference :: : my_library.my_module.my_class See the Usage section of the docs for more examples!","title":"Overview"},{"location":"#mkdocstrings","text":"Automatic documentation from sources, for MkDocs. Features Python handler features Requirements Installation Quick usage","title":"mkdocstrings"},{"location":"#features","text":"Language agnostic: just like mkdocs , mkdocstrings is written in Python but is language-agnostic. It means you can use it for any language, as long as you implement a handler for it. Currently, we only have a Python handler . Maybe you'd like to contribute another one ? Multiple themes support: each handler can offer multiple themes. Currently, we only offer the Material theme for the Python handler. Cross-references to other objects: mkdocstrings makes it possible to reference other headings from your Markdown files with the classic Markdown syntax: [identifier][] or [title][identifier] . This feature is language agnostic as well: you can cross-reference any heading that appear in your Markdown pages. If the handler for a particular language renders headings for documented objects, you'll be able to reference them! Inline injection in Markdown: instead of generating Markdown files, mkdocstrings allows you to inject documentation anywhere in your Markdown contents. The syntax is simple: ::: identifier followed by a 4-spaces indented YAML block. The identifier and YAML configuration will be passed to the appropriate handler to collect and render documentation. Global and local configuration: each handler can be configured globally in mkdocs.yml , and locally for each \"autodoc\" instruction. Watch source code directories: you can tell mkdocstrings to add directories to be watched by mkdocs when serving the documentation, for auto-reload. Sane defaults: you should be able to just drop the plugin in your configuration and enjoy your auto-generated docs.","title":"Features"},{"location":"#python-handler-features","text":"Data collection from source code : collection of the object-tree and the docstrings is done by pytkdocs . The following features are possible thanks to it: Support for type annotations: pytkdocs collects your type annotations and mkdocstrings uses them to display parameters types or return types. Recursive documentation of Python objects: just use the module dotted-path as identifier, and you get the full module docs. You don't need to inject documentation for each class, function, etc. Support for documented attribute: attributes (variables) followed by a docstring (triple-quoted string) will be recognized by pytkdocs in modules, classes and even in __init__ methods. Support for objects properties: pytkdocs detects if a method is a staticmethod , a classmethod , etc., it also detects if a property is read-only or writable, and more! These properties will be displayed next to the object signature by mkdocstrings . Google-style sections support in docstrings: pytkdocs understands Arguments: , Raises: and Returns: sections, and returns structured data for mkdocstrings to render them. Admonition support in docstrings: blocks like Note: or Warning: will be transformed to their admonition equivalent. We do not support nested admonitions in docstrings! Every object has a TOC entry: we render a heading for each object, meaning mkdocs picks them into the Table of Contents, which is nicely display by the Material theme. Thanks to mkdocstrings cross-reference ability, you can even reference other objects within your docstrings, with the classic Markdown syntax: [this object][package.module.object] or directly with [package.module.object][] Source code display: mkdocstrings can add a collapsible div containing the highlighted source code of the Python object. To get an example of what is possible, check mkdocstrings ' own documentation , auto-generated from sources by itself of course, and the following GIF:","title":"Python handler features"},{"location":"#roadmap","text":"December-January 2020: Proof of Concept. January-March 2020: Refactor. March-April 2020: Test suite for pytkdocs . Bug fixes, enhancements. May-June 2020: Test suite for mkdocstrings itself. Better documentation. Maybe a second handler, just for the fun.","title":"Roadmap"},{"location":"#requirements","text":"mkdocstrings requires Python 3.6 or above. To install Python 3.6, I recommend using pyenv . # install pyenv git clone https://github.com/pyenv/pyenv ~/.pyenv # setup pyenv (you should also put these three lines in .bashrc or similar) export PATH = \" ${ HOME } /.pyenv/bin: ${ PATH } \" export PYENV_ROOT = \" ${ HOME } /.pyenv\" eval \" $( pyenv init - ) \" # install Python 3.6 pyenv install 3 .6.12 # make it available globally pyenv global system 3 .6.12 This project currently only works with the Material theme of MkDocs. Therefore, it is required that you have it installed. pip install mkdocs-material","title":"Requirements"},{"location":"#installation","text":"With pip : python3.6 -m pip install mkdocstrings","title":"Installation"},{"location":"#quick-usage","text":"# mkdocs.yml theme : name : \"material\" plugins : - search - mkdocstrings In one of your markdown files: # Reference :: : my_library.my_module.my_class See the Usage section of the docs for more examples!","title":"Quick usage"},{"location":"changelog/","text":"Changelog \u00a4 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning . 0.13.5 - 2020-09-28 \u00a4 Compare with 0.13.4 Packaging \u00a4 Accept pytkdocs version up to 0.9.x ( changelog ). 0.13.4 - 2020-09-25 \u00a4 Compare with 0.13.3 Bug Fixes \u00a4 Bring back arbitrary **config to Python handler ( fca7d4c by Florimond Manca). Issue #154 , PR #155 0.13.3 - 2020-09-25 \u00a4 Compare with 0.13.2 Packaging \u00a4 Accept pytkdocs version up to 0.8.x ( changelog ). 0.13.2 - 2020-09-08 \u00a4 Compare with 0.13.1 Bug Fixes \u00a4 Fix relative URLs when use_directory_urls is false ( 421d189 by Timoth\u00e9e Mazzucotelli). References: #149 0.13.1 - 2020-09-03 \u00a4 Compare with 0.13.0 Bug Fixes \u00a4 Use relative links for cross-references ( 9c77f1f by Timoth\u00e9e Mazzucotelli). References: #144 , #147 0.13.0 - 2020-08-21 \u00a4 Compare with 0.12.2 Bug Fixes \u00a4 Accept dashes in module names ( fcf79d0 by Timoth\u00e9e Mazzucotelli). References: #140 Features \u00a4 Add option to show full path of direct members only ( d1b9401 by Aaron Dunmore). References: #134 , #136 Packaging \u00a4 Accept pymdown-extensions versions up to 0.8.x ( see release notes ) ( 178d48d by Hugo van Kemenade). PR #146 0.12.2 - 2020-07-24 \u00a4 Compare with 0.12.1 Packaging \u00a4 Accept pytkdocs version up to 0.7.x ( changelog ). 0.12.1 - 2020-07-07 \u00a4 Compare with 0.12.0 Bug Fixes \u00a4 Fix HTML-escaped sequence parsing as XML ( db297f1 by Timoth\u00e9e Mazzucotelli). Allow running mkdocs from non-default interpreter ( 283dd7b by Jared Khan). 0.12.0 - 2020-06-14 \u00a4 Compare with 0.11.4 Features \u00a4 Support attributes section in Google-style docstrings ( 8300253 by Timoth\u00e9e Mazzucotelli). References: #88 Support examples section in Google-style docstrings ( 650c754 by Iago Gonz\u00e1lez). References: #112 Packaging \u00a4 Accept pytkdocs version up to 0.6.x ( changelog ). 0.11.4 - 2020-06-08 \u00a4 Compare with 0.11.3 Packaging \u00a4 Accept pytkdocs version up to 0.5.x ( changelog ). If it breaks your docs, please open issues on pytkdocs ' bug-tracker , or pin pytkdocs version to while waiting for bug fixes <0.5.0 . 0.11.3 - 2020-06-07 \u00a4 Compare with 0.11.2 Bug Fixes \u00a4 Support custom theme directory configuration ( 1243cf6 by Abhishek Thakur). References: #120 , #121 0.11.2 - 2020-05-20 \u00a4 Compare with 0.11.1 Packaging \u00a4 Increase pytkdocs version range to accept 0.4.0 ( changelog ). 0.11.1 - 2020-05-14 \u00a4 Compare with 0.11.0 Bug Fixes \u00a4 Fix integration with mkdocs logging une bonne fois pour toute ( 3293cbf by Timoth\u00e9e Mazzucotelli). Discard setup commands stdout ( ea44cea by Timoth\u00e9e Mazzucotelli). References: #91 Use the proper python executable to start subprocesses ( 9fe3b39 by Reece Dunham). References: #91 , #103 0.11.0 - 2020-04-23 \u00a4 Compare with 0.10.3 Bug Fixes \u00a4 Properly raise on errors (respect strict mode) ( 2097208 by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #86 Hook properly to MkDocs logging ( b23daed by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #86 Features \u00a4 Add setup_commands option to python handler ( 599f8e5 by Ross Mechanic). Related issues/PRs: #89 , #90 Add option to allow overriding templates ( 7360021 by Mika\u00ebl Capelle). Related issues/PRs: #59 , #82 0.10.3 - 2020-04-10 \u00a4 Compare with 0.10.2 Bug Fixes \u00a4 Handle site_url not being defined ( 9fb4a9b by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #77 Packaging \u00a4 This version increases the accepted range of versions for the pytkdocs dependency to >=0.2.0, <0.4.0 . The pytkdocs project just released version 0.3.0 which: adds support for complex markup in docstrings sections items descriptions adds support for different indentations in docstrings sections (tabulations or less/more than 4 spaces) fixes docstring parsing for arguments whose names start with * , like *args and **kwargs 0.10.2 - 2020-04-07 \u00a4 Compare with 0.10.1 Packaging \u00a4 This version increases the accepted range of versions for the pymdown-extensions dependency, as well as for the mkdocs-material development dependency. Indeed, both these projects recently released major versions 7 and 5 respectively. Users who wish to use these new versions will be able to. See issue #74 . 0.10.1 - 2020-04-03 \u00a4 Compare with 0.10.0 Bug Fixes \u00a4 Fix jinja2 error for jinja2 < 2.11 ( 387f970 by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #67 , #72 Fix missing dependency pymdown-extensions ( 648b99d by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #66 Fix heading level of hidden toc entries ( 475cc62 by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #65 Fix rendering signatures containing keyword_only ( c6c5add by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #68 0.10.0 - 2020-03-27 \u00a4 Compare with 0.9.1 Features \u00a4 Prepare for new pytkdocs version ( 336421a ). Add options filters and members to the Python collector to reflect the new pytkdocs options. See the default configuration of the Python collector . 0.9.1 - 2020-03-21 \u00a4 Compare with 0.9.0 Bug fixes \u00a4 Fix cross-references when deploying to GitHub pages ( 36f804b ). 0.9.0 - 2020-03-21 \u00a4 Compare with 0.8.0 This version is a big refactor. We will just list the new features without pointing to particular commits. The documentation rendering looks slightly different, and should be better than before. No identified breaking changes for end-users. Features \u00a4 Language agnostic: we moved the code responsible for loading Python documentation into a new project, pytkdocs , and implemented a \"handlers\" logic, effectively allowing to support any given language. Waiting for your handlers contributions ! Multiple themes support: handlers can offer templates for multiple mkdocs themes. Better cross-references: cross-references now not only work between documented objects (between all languages, given the objects' identifiers are unique), but also for every heading of your Markdown pages. Configuration options: the rendering of Python documentation can now be configured, (globally and locally thanks to the handlers system), check the docs! Also see the recommended CSS . Proper logging messages: mkdocstrings now logs debug, warning and error messages, useful when troubleshooting. Bug fixes \u00a4 Various fixes and better error handling. 0.8.0 - 2020-03-04 \u00a4 Compare with 0.7.2 Breaking Changes \u00a4 Be compatible with Mkdocs >= 1.1 ( 5a974a4 ). This is a breaking change as we're not compatible with versions of Mkdocs below 1.1 anymore. If you cannot upgrade Mkdocs to 1.1, pin mkdocstrings' version to 0.7.2. 0.7.2 - 2020-03-04 \u00a4 Compare with 0.7.1 Bug Fixes \u00a4 Catch OSError when trying to get source lines ( 8e8d604 ). Do not render signature empty sentinel ( 16dfd73 ). Fix for nested classes and their attributes ( 7fef903 ). Fix relative_file_path method ( 52715ad ). Wrap file path in backticks to escape it ( 2525f39 ). 0.7.1 - 2020-02-18 \u00a4 Compare with 0.7.0 Bug Fixes \u00a4 Replace literal slash with os.sep for Windows compatibility ( 70f9af5 ). 0.7.0 - 2020-01-13 \u00a4 Compare with 0.6.1 Bug Fixes \u00a4 Don't mark args or kwargs as required ( 4049d6f ). Filter submodules ( 7b11095 ). Code Refactoring \u00a4 Don't guess lang in generated docs ( db4f60a ). Render at HTML step with custom markdown converter ( 9b5a3e1 ). Features \u00a4 Change forward ref to ref, fix optional unions ( 2f0bfaa ). Discover package submodules ( 231062a ). Implement watched source code (hacks) ( 4a67953 ). 0.6.1 - 2020-01-02 \u00a4 Compare with 0.6.0 Bug Fixes \u00a4 Break docstring discarding loop if found ( 5a17fec ). Fix discarding docstring ( 143f7cb ). Fix getting annotation from nodes ( ecde72b ). Fix various things ( affbf06 ). Code Refactoring \u00a4 Break as soon as we find the same attr in a parent class while trying to discard the docstring ( 65d7908 ). Split Docstring.parse method to improve readability ( 2226e2d ). 0.6.0 - 2019-12-28 \u00a4 Compare with 0.5.0 Bug Fixes \u00a4 Fix GenericMeta import error on Python 3.7+ ( febf2b9 ). Code Refactoring \u00a4 More classes. Still ugly code though :'( ( f41c119 ). Split into more modules ( f1872a4 ). Use Object subclasses ( 40dd106 ). 0.5.0 - 2019-12-22 \u00a4 Compare with 0.4.0 Features \u00a4 Use divs in HTML contents to ease styling ( 2a36a0e ). 0.4.0 - 2019-12-22 \u00a4 Compare with 0.3.0 Features \u00a4 Parse docstrings Google-style blocks, get types from signature ( 5af0c7b ). 0.3.0 - 2019-12-21 \u00a4 Compare with 0.2.0 Features \u00a4 Allow object referencing in docstrings ( 2dd50c0 ). 0.2.0 - 2019-12-15 \u00a4 Compare with 0.1.0 Misc \u00a4 Refactor, features, etc. ( 111fa85 ). 0.1.0 - 2019-12-12 \u00a4 Compare with first commit Misc \u00a4 Clean up (delete unused files) ( c227043 ). Clean up unused makefile rules ( edc01e9 ). Initial commit ( f1dd8fb ). Update readme ( ae56bdd ). Add plugin ( 6ed5cb1 ). First PoC, needs better theming ( 18a00b9 ). Get attributes docstrings ( 7838fff ). Refactor ( f68f1a8 ).","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#0135-2020-09-28","text":"Compare with 0.13.4","title":"0.13.5 - 2020-09-28"},{"location":"changelog/#packaging","text":"Accept pytkdocs version up to 0.9.x ( changelog ).","title":"Packaging"},{"location":"changelog/#0134-2020-09-25","text":"Compare with 0.13.3","title":"0.13.4 - 2020-09-25"},{"location":"changelog/#bug-fixes","text":"Bring back arbitrary **config to Python handler ( fca7d4c by Florimond Manca). Issue #154 , PR #155","title":"Bug Fixes"},{"location":"changelog/#0133-2020-09-25","text":"Compare with 0.13.2","title":"0.13.3 - 2020-09-25"},{"location":"changelog/#packaging_1","text":"Accept pytkdocs version up to 0.8.x ( changelog ).","title":"Packaging"},{"location":"changelog/#0132-2020-09-08","text":"Compare with 0.13.1","title":"0.13.2 - 2020-09-08"},{"location":"changelog/#bug-fixes_1","text":"Fix relative URLs when use_directory_urls is false ( 421d189 by Timoth\u00e9e Mazzucotelli). References: #149","title":"Bug Fixes"},{"location":"changelog/#0131-2020-09-03","text":"Compare with 0.13.0","title":"0.13.1 - 2020-09-03"},{"location":"changelog/#bug-fixes_2","text":"Use relative links for cross-references ( 9c77f1f by Timoth\u00e9e Mazzucotelli). References: #144 , #147","title":"Bug Fixes"},{"location":"changelog/#0130-2020-08-21","text":"Compare with 0.12.2","title":"0.13.0 - 2020-08-21"},{"location":"changelog/#bug-fixes_3","text":"Accept dashes in module names ( fcf79d0 by Timoth\u00e9e Mazzucotelli). References: #140","title":"Bug Fixes"},{"location":"changelog/#features","text":"Add option to show full path of direct members only ( d1b9401 by Aaron Dunmore). References: #134 , #136","title":"Features"},{"location":"changelog/#packaging_2","text":"Accept pymdown-extensions versions up to 0.8.x ( see release notes ) ( 178d48d by Hugo van Kemenade). PR #146","title":"Packaging"},{"location":"changelog/#0122-2020-07-24","text":"Compare with 0.12.1","title":"0.12.2 - 2020-07-24"},{"location":"changelog/#packaging_3","text":"Accept pytkdocs version up to 0.7.x ( changelog ).","title":"Packaging"},{"location":"changelog/#0121-2020-07-07","text":"Compare with 0.12.0","title":"0.12.1 - 2020-07-07"},{"location":"changelog/#bug-fixes_4","text":"Fix HTML-escaped sequence parsing as XML ( db297f1 by Timoth\u00e9e Mazzucotelli). Allow running mkdocs from non-default interpreter ( 283dd7b by Jared Khan).","title":"Bug Fixes"},{"location":"changelog/#0120-2020-06-14","text":"Compare with 0.11.4","title":"0.12.0 - 2020-06-14"},{"location":"changelog/#features_1","text":"Support attributes section in Google-style docstrings ( 8300253 by Timoth\u00e9e Mazzucotelli). References: #88 Support examples section in Google-style docstrings ( 650c754 by Iago Gonz\u00e1lez). References: #112","title":"Features"},{"location":"changelog/#packaging_4","text":"Accept pytkdocs version up to 0.6.x ( changelog ).","title":"Packaging"},{"location":"changelog/#0114-2020-06-08","text":"Compare with 0.11.3","title":"0.11.4 - 2020-06-08"},{"location":"changelog/#packaging_5","text":"Accept pytkdocs version up to 0.5.x ( changelog ). If it breaks your docs, please open issues on pytkdocs ' bug-tracker , or pin pytkdocs version to while waiting for bug fixes <0.5.0 .","title":"Packaging"},{"location":"changelog/#0113-2020-06-07","text":"Compare with 0.11.2","title":"0.11.3 - 2020-06-07"},{"location":"changelog/#bug-fixes_5","text":"Support custom theme directory configuration ( 1243cf6 by Abhishek Thakur). References: #120 , #121","title":"Bug Fixes"},{"location":"changelog/#0112-2020-05-20","text":"Compare with 0.11.1","title":"0.11.2 - 2020-05-20"},{"location":"changelog/#packaging_6","text":"Increase pytkdocs version range to accept 0.4.0 ( changelog ).","title":"Packaging"},{"location":"changelog/#0111-2020-05-14","text":"Compare with 0.11.0","title":"0.11.1 - 2020-05-14"},{"location":"changelog/#bug-fixes_6","text":"Fix integration with mkdocs logging une bonne fois pour toute ( 3293cbf by Timoth\u00e9e Mazzucotelli). Discard setup commands stdout ( ea44cea by Timoth\u00e9e Mazzucotelli). References: #91 Use the proper python executable to start subprocesses ( 9fe3b39 by Reece Dunham). References: #91 , #103","title":"Bug Fixes"},{"location":"changelog/#0110-2020-04-23","text":"Compare with 0.10.3","title":"0.11.0 - 2020-04-23"},{"location":"changelog/#bug-fixes_7","text":"Properly raise on errors (respect strict mode) ( 2097208 by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #86 Hook properly to MkDocs logging ( b23daed by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #86","title":"Bug Fixes"},{"location":"changelog/#features_2","text":"Add setup_commands option to python handler ( 599f8e5 by Ross Mechanic). Related issues/PRs: #89 , #90 Add option to allow overriding templates ( 7360021 by Mika\u00ebl Capelle). Related issues/PRs: #59 , #82","title":"Features"},{"location":"changelog/#0103-2020-04-10","text":"Compare with 0.10.2","title":"0.10.3 - 2020-04-10"},{"location":"changelog/#bug-fixes_8","text":"Handle site_url not being defined ( 9fb4a9b by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #77","title":"Bug Fixes"},{"location":"changelog/#packaging_7","text":"This version increases the accepted range of versions for the pytkdocs dependency to >=0.2.0, <0.4.0 . The pytkdocs project just released version 0.3.0 which: adds support for complex markup in docstrings sections items descriptions adds support for different indentations in docstrings sections (tabulations or less/more than 4 spaces) fixes docstring parsing for arguments whose names start with * , like *args and **kwargs","title":"Packaging"},{"location":"changelog/#0102-2020-04-07","text":"Compare with 0.10.1","title":"0.10.2 - 2020-04-07"},{"location":"changelog/#packaging_8","text":"This version increases the accepted range of versions for the pymdown-extensions dependency, as well as for the mkdocs-material development dependency. Indeed, both these projects recently released major versions 7 and 5 respectively. Users who wish to use these new versions will be able to. See issue #74 .","title":"Packaging"},{"location":"changelog/#0101-2020-04-03","text":"Compare with 0.10.0","title":"0.10.1 - 2020-04-03"},{"location":"changelog/#bug-fixes_9","text":"Fix jinja2 error for jinja2 < 2.11 ( 387f970 by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #67 , #72 Fix missing dependency pymdown-extensions ( 648b99d by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #66 Fix heading level of hidden toc entries ( 475cc62 by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #65 Fix rendering signatures containing keyword_only ( c6c5add by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #68","title":"Bug Fixes"},{"location":"changelog/#0100-2020-03-27","text":"Compare with 0.9.1","title":"0.10.0 - 2020-03-27"},{"location":"changelog/#features_3","text":"Prepare for new pytkdocs version ( 336421a ). Add options filters and members to the Python collector to reflect the new pytkdocs options. See the default configuration of the Python collector .","title":"Features"},{"location":"changelog/#091-2020-03-21","text":"Compare with 0.9.0","title":"0.9.1 - 2020-03-21"},{"location":"changelog/#bug-fixes_10","text":"Fix cross-references when deploying to GitHub pages ( 36f804b ).","title":"Bug fixes"},{"location":"changelog/#090-2020-03-21","text":"Compare with 0.8.0 This version is a big refactor. We will just list the new features without pointing to particular commits. The documentation rendering looks slightly different, and should be better than before. No identified breaking changes for end-users.","title":"0.9.0 - 2020-03-21"},{"location":"changelog/#features_4","text":"Language agnostic: we moved the code responsible for loading Python documentation into a new project, pytkdocs , and implemented a \"handlers\" logic, effectively allowing to support any given language. Waiting for your handlers contributions ! Multiple themes support: handlers can offer templates for multiple mkdocs themes. Better cross-references: cross-references now not only work between documented objects (between all languages, given the objects' identifiers are unique), but also for every heading of your Markdown pages. Configuration options: the rendering of Python documentation can now be configured, (globally and locally thanks to the handlers system), check the docs! Also see the recommended CSS . Proper logging messages: mkdocstrings now logs debug, warning and error messages, useful when troubleshooting.","title":"Features"},{"location":"changelog/#bug-fixes_11","text":"Various fixes and better error handling.","title":"Bug fixes"},{"location":"changelog/#080-2020-03-04","text":"Compare with 0.7.2","title":"0.8.0 - 2020-03-04"},{"location":"changelog/#breaking-changes","text":"Be compatible with Mkdocs >= 1.1 ( 5a974a4 ). This is a breaking change as we're not compatible with versions of Mkdocs below 1.1 anymore. If you cannot upgrade Mkdocs to 1.1, pin mkdocstrings' version to 0.7.2.","title":"Breaking Changes"},{"location":"changelog/#072-2020-03-04","text":"Compare with 0.7.1","title":"0.7.2 - 2020-03-04"},{"location":"changelog/#bug-fixes_12","text":"Catch OSError when trying to get source lines ( 8e8d604 ). Do not render signature empty sentinel ( 16dfd73 ). Fix for nested classes and their attributes ( 7fef903 ). Fix relative_file_path method ( 52715ad ). Wrap file path in backticks to escape it ( 2525f39 ).","title":"Bug Fixes"},{"location":"changelog/#071-2020-02-18","text":"Compare with 0.7.0","title":"0.7.1 - 2020-02-18"},{"location":"changelog/#bug-fixes_13","text":"Replace literal slash with os.sep for Windows compatibility ( 70f9af5 ).","title":"Bug Fixes"},{"location":"changelog/#070-2020-01-13","text":"Compare with 0.6.1","title":"0.7.0 - 2020-01-13"},{"location":"changelog/#bug-fixes_14","text":"Don't mark args or kwargs as required ( 4049d6f ). Filter submodules ( 7b11095 ).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring","text":"Don't guess lang in generated docs ( db4f60a ). Render at HTML step with custom markdown converter ( 9b5a3e1 ).","title":"Code Refactoring"},{"location":"changelog/#features_5","text":"Change forward ref to ref, fix optional unions ( 2f0bfaa ). Discover package submodules ( 231062a ). Implement watched source code (hacks) ( 4a67953 ).","title":"Features"},{"location":"changelog/#061-2020-01-02","text":"Compare with 0.6.0","title":"0.6.1 - 2020-01-02"},{"location":"changelog/#bug-fixes_15","text":"Break docstring discarding loop if found ( 5a17fec ). Fix discarding docstring ( 143f7cb ). Fix getting annotation from nodes ( ecde72b ). Fix various things ( affbf06 ).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_1","text":"Break as soon as we find the same attr in a parent class while trying to discard the docstring ( 65d7908 ). Split Docstring.parse method to improve readability ( 2226e2d ).","title":"Code Refactoring"},{"location":"changelog/#060-2019-12-28","text":"Compare with 0.5.0","title":"0.6.0 - 2019-12-28"},{"location":"changelog/#bug-fixes_16","text":"Fix GenericMeta import error on Python 3.7+ ( febf2b9 ).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_2","text":"More classes. Still ugly code though :'( ( f41c119 ). Split into more modules ( f1872a4 ). Use Object subclasses ( 40dd106 ).","title":"Code Refactoring"},{"location":"changelog/#050-2019-12-22","text":"Compare with 0.4.0","title":"0.5.0 - 2019-12-22"},{"location":"changelog/#features_6","text":"Use divs in HTML contents to ease styling ( 2a36a0e ).","title":"Features"},{"location":"changelog/#040-2019-12-22","text":"Compare with 0.3.0","title":"0.4.0 - 2019-12-22"},{"location":"changelog/#features_7","text":"Parse docstrings Google-style blocks, get types from signature ( 5af0c7b ).","title":"Features"},{"location":"changelog/#030-2019-12-21","text":"Compare with 0.2.0","title":"0.3.0 - 2019-12-21"},{"location":"changelog/#features_8","text":"Allow object referencing in docstrings ( 2dd50c0 ).","title":"Features"},{"location":"changelog/#020-2019-12-15","text":"Compare with 0.1.0","title":"0.2.0 - 2019-12-15"},{"location":"changelog/#misc","text":"Refactor, features, etc. ( 111fa85 ).","title":"Misc"},{"location":"changelog/#010-2019-12-12","text":"Compare with first commit","title":"0.1.0 - 2019-12-12"},{"location":"changelog/#misc_1","text":"Clean up (delete unused files) ( c227043 ). Clean up unused makefile rules ( edc01e9 ). Initial commit ( f1dd8fb ). Update readme ( ae56bdd ). Add plugin ( 6ed5cb1 ). First PoC, needs better theming ( 18a00b9 ). Get attributes docstrings ( 7838fff ). Refactor ( f68f1a8 ).","title":"Misc"},{"location":"code_of_conduct/","text":"Contributor Covenant Code of Conduct \u00a4 Our Pledge \u00a4 In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards \u00a4 Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities \u00a4 Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope \u00a4 This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement \u00a4 Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution \u00a4 This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Code of Conduct"},{"location":"code_of_conduct/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"code_of_conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"code_of_conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code_of_conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"code_of_conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"code_of_conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"code_of_conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Attribution"},{"location":"contributing/","text":"Contributing \u00a4 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. Environment setup \u00a4 Nothing easier! Fork and clone the repository, then: cd mkdocstrings make setup Note If it fails for some reason, you'll need to install these tools manually: Poetry and Invoke . You can install them with: python3 -m pip install --user pipx pipx install poetry pipx install invoke Now you can try running make setup again, or simply poetry install . You now have the dependencies installed. Run make help to see all the available actions! Tasks \u00a4 This project uses Invoke to run tasks. A Makefile is also provided. The Makefile will try to run the task on multiple Python versions. If for some reason you don't want to run the task on multiple Python versions, you can do one of the following: export PYTHON_VERSIONS= : this will run the task with only the current Python version run the task directly with poetry run invoke TASK , or invoke TASK if the environment was already activated through poetry shell The Makefile detects if the Poetry environment is activated, so make will work the same with the virtualenv activated or not. Development \u00a4 As usual: create a new branch: git checkout -b feature-or-bugfix-name edit the code and/or the documentation If you updated the documentation or the project dependencies: run make docs-regen run make docs-serve , go to http://localhost:8000 and check that everything looks good Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) follow our commit message convention If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review. Don't bother updating the changelog, we will take care of this. Commit message convention \u00a4 Commits messages must follow the Angular style : <type>[(scope)]: Subject [Body] Scope and body are optional. Type can be: build : About packaging, building wheels, etc. chore : About packaging or repo/files management. ci : About Continuous Integration. docs : About documentation. feat : New feature. fix : Bug fix. perf : About performance. refactor : Changes which are not features nor bug fixes. style : A change in code style/format. tests : About tests. Subject (and body) must be valid Markdown. If you write a body, please add issues references at the end: Body. References: #10, #11. Fixes #15. Pull requests guidelines \u00a4 Link to any related issue in the Pull Request message. During review, we recommend using fixups: # SHA is the SHA of the commit you want to fix git commit --fixup = SHA Once all the changes are approved, you can squash your commits: git rebase -i --autosquash master And force-push: git push -f If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.","title":"Contributing"},{"location":"contributing/#environment-setup","text":"Nothing easier! Fork and clone the repository, then: cd mkdocstrings make setup Note If it fails for some reason, you'll need to install these tools manually: Poetry and Invoke . You can install them with: python3 -m pip install --user pipx pipx install poetry pipx install invoke Now you can try running make setup again, or simply poetry install . You now have the dependencies installed. Run make help to see all the available actions!","title":"Environment setup"},{"location":"contributing/#tasks","text":"This project uses Invoke to run tasks. A Makefile is also provided. The Makefile will try to run the task on multiple Python versions. If for some reason you don't want to run the task on multiple Python versions, you can do one of the following: export PYTHON_VERSIONS= : this will run the task with only the current Python version run the task directly with poetry run invoke TASK , or invoke TASK if the environment was already activated through poetry shell The Makefile detects if the Poetry environment is activated, so make will work the same with the virtualenv activated or not.","title":"Tasks"},{"location":"contributing/#development","text":"As usual: create a new branch: git checkout -b feature-or-bugfix-name edit the code and/or the documentation If you updated the documentation or the project dependencies: run make docs-regen run make docs-serve , go to http://localhost:8000 and check that everything looks good Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) follow our commit message convention If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review. Don't bother updating the changelog, we will take care of this.","title":"Development"},{"location":"contributing/#commit-message-convention","text":"Commits messages must follow the Angular style : <type>[(scope)]: Subject [Body] Scope and body are optional. Type can be: build : About packaging, building wheels, etc. chore : About packaging or repo/files management. ci : About Continuous Integration. docs : About documentation. feat : New feature. fix : Bug fix. perf : About performance. refactor : Changes which are not features nor bug fixes. style : A change in code style/format. tests : About tests. Subject (and body) must be valid Markdown. If you write a body, please add issues references at the end: Body. References: #10, #11. Fixes #15.","title":"Commit message convention"},{"location":"contributing/#pull-requests-guidelines","text":"Link to any related issue in the Pull Request message. During review, we recommend using fixups: # SHA is the SHA of the commit you want to fix git commit --fixup = SHA Once all the changes are approved, you can squash your commits: git rebase -i --autosquash master And force-push: git push -f If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.","title":"Pull requests guidelines"},{"location":"credits/","text":"Credits \u00a4 These projects were used to build mkdocstrings . Thank you! python | poetry | copier-poetry Direct dependencies \u00a4 autoflake | beautifulsoup4 | black | coverage | failprint | flake8-black | flake8-builtins | flake8-pytest-style | flake8-tidy-imports | flake8-variables-names | flakehell | git-changelog | httpx | invoke | ipython | isort | jinja2-cli | mkdocs | mkdocs-material | mypy | pymdown-extensions | pytest | pytest-cov | pytest-randomly | pytest-sugar | pytest-xdist | pytkdocs | toml | wemake-python-styleguide | wrapt Indirect dependencies \u00a4 ansimarkup | apipkg | appdirs | appnope | astor | astroid | atomicwrites | attrs | backcall | bandit | certifi | chardet | click | colorama | contextvars | darglint | dataclasses | decorator | docutils | entrypoints | eradicate | execnet | flake8 | flake8-bandit | flake8-broken-line | flake8-bugbear | flake8-commas | flake8-comprehensions | flake8-debugger | flake8-docstrings | flake8-eradicate | flake8-isort | flake8-plugin-utils | flake8-polyfill | flake8-quotes | flake8-rst-docstrings | flake8-string-format | future | gitdb | GitPython | h11 | httpcore | idna | immutables | importlib-metadata | iniconfig | ipython-genutils | jedi | Jinja2 | joblib | lazy-object-proxy | livereload | lunr | Markdown | MarkupSafe | mccabe | mkdocs-material-extensions | more-itertools | mypy-extensions | nltk | packaging | parso | pathspec | pbr | pep8-naming | pexpect | pickleshare | pluggy | prompt-toolkit | ptyprocess | py | pycodestyle | pydocstyle | pyflakes | Pygments | pylint | pyparsing | pytest-forked | PyYAML | regex | restructuredtext-lint | rfc3986 | six | smmap | sniffio | snowballstemmer | soupsieve | stevedore | termcolor | testfixtures | tornado | tqdm | traitlets | typed-ast | typing-extensions | urllib3 | wcwidth | zipp More credits from the author","title":"Credits"},{"location":"credits/#credits","text":"These projects were used to build mkdocstrings . Thank you! python | poetry | copier-poetry","title":"Credits"},{"location":"credits/#direct-dependencies","text":"autoflake | beautifulsoup4 | black | coverage | failprint | flake8-black | flake8-builtins | flake8-pytest-style | flake8-tidy-imports | flake8-variables-names | flakehell | git-changelog | httpx | invoke | ipython | isort | jinja2-cli | mkdocs | mkdocs-material | mypy | pymdown-extensions | pytest | pytest-cov | pytest-randomly | pytest-sugar | pytest-xdist | pytkdocs | toml | wemake-python-styleguide | wrapt","title":"Direct dependencies"},{"location":"credits/#indirect-dependencies","text":"ansimarkup | apipkg | appdirs | appnope | astor | astroid | atomicwrites | attrs | backcall | bandit | certifi | chardet | click | colorama | contextvars | darglint | dataclasses | decorator | docutils | entrypoints | eradicate | execnet | flake8 | flake8-bandit | flake8-broken-line | flake8-bugbear | flake8-commas | flake8-comprehensions | flake8-debugger | flake8-docstrings | flake8-eradicate | flake8-isort | flake8-plugin-utils | flake8-polyfill | flake8-quotes | flake8-rst-docstrings | flake8-string-format | future | gitdb | GitPython | h11 | httpcore | idna | immutables | importlib-metadata | iniconfig | ipython-genutils | jedi | Jinja2 | joblib | lazy-object-proxy | livereload | lunr | Markdown | MarkupSafe | mccabe | mkdocs-material-extensions | more-itertools | mypy-extensions | nltk | packaging | parso | pathspec | pbr | pep8-naming | pexpect | pickleshare | pluggy | prompt-toolkit | ptyprocess | py | pycodestyle | pydocstyle | pyflakes | Pygments | pylint | pyparsing | pytest-forked | PyYAML | regex | restructuredtext-lint | rfc3986 | six | smmap | sniffio | snowballstemmer | soupsieve | stevedore | termcolor | testfixtures | tornado | tqdm | traitlets | typed-ast | typing-extensions | urllib3 | wcwidth | zipp More credits from the author","title":"Indirect dependencies"},{"location":"license/","text":"ISC License Copyright (c) 2019, Timoth\u00e9e Mazzucotelli Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies. THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.","title":"License"},{"location":"troubleshooting/","text":"Troubleshooting \u00a4 Code blocks in admonitions (in docstrings or else) are not rendered correctly \u00a4 To render code blocks in admonitions, you need to add the pymdownx.superfences extensions to the list of Markdown extensions in mkdocs.yml . For example: !!! note Some text. ```bash echo \"some code\" ``` # mkdocs.yml markdown_extensions : - admonition - codehilite - pymdownx.superfences MkDocs warns me about links to unfound documentation files \u00a4 A warning like this one: WARNING - Documentation file 'reference/parsers/docstrings.md' contains a link to 'reference/parsers/pytkdocs.parsers.docstrings.Section' which is not found in the documentation files. ...generally means you used parentheses () instead of brackets [] for a cross-reference. Notice the dots in reference/parsers/pytkdocs.parsers.docstrings.Section ? It shows that it's probably a cross-reference, not a direct link. It's probably written like [Section](pytkdocs.parsers.docstrings.Section) in the docs, when it should be [Section][pytkdocs.parsers.docstrings.Section] . Nothing is rendered at all \u00a4 Python? \"No\": we only support Python right now. \"Yes\": is your package available in the Python path? See Python handler: Finding module . Some objects are not rendered (they do not appear in the generated docs) \u00a4 Make sure the configuration options of the handler for both selection and rendering are correct. Check the documentation for Handlers to see the available options for each handler. Also make sure your documentation in your source code is formatted correctly. For Python code, check the supported docstring styles page. Re-run the Mkdocs command with -v , and carefully read any traceback. The generated documentation does not look good \u00a4 Are you using the Material theme? \"No\": We do not support any other theme yet. Check the bugtracker to see if there is a feature request asking to support your theme. If you find one, vote with a thumbs up. If not, you can open a ticket. \"Yes\": Please open an ticket on the bugtracker with a detailed explanation and screenshots of the bad-looking parts. Warning: could not find cross-reference target \u00a4 Make sure you have defined site_url in mkdocs.yml , as it is required for cross-references when building the site (the error does not happen when serving because then site_url is auto-populated by mkdocs ). Make sure the referenced object was both collected and rendered: verify your selection and rendering options. For false-positives, you can wrap the text in backticks (`) to prevent mkdocstrings from trying to process it. WindowsPath object is not iterable \u00a4 If you get a traceback like this one: ... File \"c:\\users\\me\\appdata\\local\\continuum\\anaconda3\\lib\\site-packages\\mkdocstrings\\handlers\\python.py\", line 244, in get_handler return PythonHandler(collector=PythonCollector(), renderer=PythonRenderer(\"python\", theme)) File \"c:\\users\\me\\appdata\\local\\continuum\\anaconda3\\lib\\site-packages\\mkdocstrings\\handlers\\__init__.py\", line 124, in __init__ self.env = Environment(autoescape=True, loader=FileSystemLoader(theme_dir)) File \"c:\\users\\me\\appdata\\local\\continuum\\anaconda3\\lib\\site-packages\\jinja2\\loaders.py\", line 163, in __init__ self.searchpath = list(searchpath) TypeError: 'WindowsPath' object is not iterable Try upgrading your installed version of Jinja2: pip install -U jinja2 Version 2.11.1 seems to be working fine. Python specifics \u00a4 LaTeX in docstrings is not rendered correctly \u00a4 If you are using a Markdown extension like Arithmatex Mathjax or markdown-katex to render LaTeX, add r in front of your docstring to make sure nothing is escaped. You'll still maybe have to play with escaping to get things right. Example: def math_function ( x , y ): r \"\"\" Look at these formulas: ```math f(x) = \\int_{-\\infty}^\\infty \\hat f(\\xi)\\,e^{2 \\pi i \\xi x} \\,d\\xi ``` \"\"\" My docstrings in comments ( #: ) are not picked up \u00a4 It's because pytkdocs does not pick up documentation in comments. To load documentation for modules, classes, methods and functions, it uses inspect . To load documentation for attributes, it uses ast to parse the source code, searching for pairs of nodes like assignment - string , and ast does not parse comments. So instead of: import enum class MyEnum ( enum . Enum ): v1 = 1 #: The first choice. v2 = 2 #: The second choice. You can use: import enum class MyEnum ( enum . Enum ): \"\"\" My enum. Attributes: v1: The first choice. v2: The second choice. \"\"\" v1 = 1 v2 = 2 Or: import enum class MyEnum ( enum . Enum ): v1 = 1 \"\"\"The first choice.\"\"\" v2 = 2 \"\"\"The second choice.\"\"\" My wrapped function shows documentation/code for its wrapper instead of its own \u00a4 Use functools.wraps() : from functools import wraps def my_decorator ( function ): \"\"\"The decorator docs.\"\"\" @wraps ( function ) def wrapped_function ( * args , ** kwargs ): print ( \"hello\" ) function ( * args , ** kwargs ) print ( \"bye\" ) return wrapped_function @my_decorator def my_function ( * args , ** kwargs ): \"\"\"The function docs.\"\"\" print ( * args , ** kwargs )","title":"Troubleshooting"},{"location":"troubleshooting/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"troubleshooting/#code-blocks-in-admonitions-in-docstrings-or-else-are-not-rendered-correctly","text":"To render code blocks in admonitions, you need to add the pymdownx.superfences extensions to the list of Markdown extensions in mkdocs.yml . For example: !!! note Some text. ```bash echo \"some code\" ``` # mkdocs.yml markdown_extensions : - admonition - codehilite - pymdownx.superfences","title":"Code blocks in admonitions (in docstrings or else) are not rendered correctly"},{"location":"troubleshooting/#mkdocs-warns-me-about-links-to-unfound-documentation-files","text":"A warning like this one: WARNING - Documentation file 'reference/parsers/docstrings.md' contains a link to 'reference/parsers/pytkdocs.parsers.docstrings.Section' which is not found in the documentation files. ...generally means you used parentheses () instead of brackets [] for a cross-reference. Notice the dots in reference/parsers/pytkdocs.parsers.docstrings.Section ? It shows that it's probably a cross-reference, not a direct link. It's probably written like [Section](pytkdocs.parsers.docstrings.Section) in the docs, when it should be [Section][pytkdocs.parsers.docstrings.Section] .","title":"MkDocs warns me about links to unfound documentation files"},{"location":"troubleshooting/#nothing-is-rendered-at-all","text":"Python? \"No\": we only support Python right now. \"Yes\": is your package available in the Python path? See Python handler: Finding module .","title":"Nothing is rendered at all"},{"location":"troubleshooting/#some-objects-are-not-rendered-they-do-not-appear-in-the-generated-docs","text":"Make sure the configuration options of the handler for both selection and rendering are correct. Check the documentation for Handlers to see the available options for each handler. Also make sure your documentation in your source code is formatted correctly. For Python code, check the supported docstring styles page. Re-run the Mkdocs command with -v , and carefully read any traceback.","title":"Some objects are not rendered (they do not appear in the generated docs)"},{"location":"troubleshooting/#the-generated-documentation-does-not-look-good","text":"Are you using the Material theme? \"No\": We do not support any other theme yet. Check the bugtracker to see if there is a feature request asking to support your theme. If you find one, vote with a thumbs up. If not, you can open a ticket. \"Yes\": Please open an ticket on the bugtracker with a detailed explanation and screenshots of the bad-looking parts.","title":"The generated documentation does not look good"},{"location":"troubleshooting/#warning-could-not-find-cross-reference-target","text":"Make sure you have defined site_url in mkdocs.yml , as it is required for cross-references when building the site (the error does not happen when serving because then site_url is auto-populated by mkdocs ). Make sure the referenced object was both collected and rendered: verify your selection and rendering options. For false-positives, you can wrap the text in backticks (`) to prevent mkdocstrings from trying to process it.","title":"Warning: could not find cross-reference target"},{"location":"troubleshooting/#windowspath-object-is-not-iterable","text":"If you get a traceback like this one: ... File \"c:\\users\\me\\appdata\\local\\continuum\\anaconda3\\lib\\site-packages\\mkdocstrings\\handlers\\python.py\", line 244, in get_handler return PythonHandler(collector=PythonCollector(), renderer=PythonRenderer(\"python\", theme)) File \"c:\\users\\me\\appdata\\local\\continuum\\anaconda3\\lib\\site-packages\\mkdocstrings\\handlers\\__init__.py\", line 124, in __init__ self.env = Environment(autoescape=True, loader=FileSystemLoader(theme_dir)) File \"c:\\users\\me\\appdata\\local\\continuum\\anaconda3\\lib\\site-packages\\jinja2\\loaders.py\", line 163, in __init__ self.searchpath = list(searchpath) TypeError: 'WindowsPath' object is not iterable Try upgrading your installed version of Jinja2: pip install -U jinja2 Version 2.11.1 seems to be working fine.","title":"WindowsPath object is not iterable"},{"location":"troubleshooting/#python-specifics","text":"","title":"Python specifics"},{"location":"troubleshooting/#latex-in-docstrings-is-not-rendered-correctly","text":"If you are using a Markdown extension like Arithmatex Mathjax or markdown-katex to render LaTeX, add r in front of your docstring to make sure nothing is escaped. You'll still maybe have to play with escaping to get things right. Example: def math_function ( x , y ): r \"\"\" Look at these formulas: ```math f(x) = \\int_{-\\infty}^\\infty \\hat f(\\xi)\\,e^{2 \\pi i \\xi x} \\,d\\xi ``` \"\"\"","title":"LaTeX in docstrings is not rendered correctly"},{"location":"troubleshooting/#my-docstrings-in-comments-are-not-picked-up","text":"It's because pytkdocs does not pick up documentation in comments. To load documentation for modules, classes, methods and functions, it uses inspect . To load documentation for attributes, it uses ast to parse the source code, searching for pairs of nodes like assignment - string , and ast does not parse comments. So instead of: import enum class MyEnum ( enum . Enum ): v1 = 1 #: The first choice. v2 = 2 #: The second choice. You can use: import enum class MyEnum ( enum . Enum ): \"\"\" My enum. Attributes: v1: The first choice. v2: The second choice. \"\"\" v1 = 1 v2 = 2 Or: import enum class MyEnum ( enum . Enum ): v1 = 1 \"\"\"The first choice.\"\"\" v2 = 2 \"\"\"The second choice.\"\"\"","title":"My docstrings in comments (#:) are not picked up"},{"location":"troubleshooting/#my-wrapped-function-shows-documentationcode-for-its-wrapper-instead-of-its-own","text":"Use functools.wraps() : from functools import wraps def my_decorator ( function ): \"\"\"The decorator docs.\"\"\" @wraps ( function ) def wrapped_function ( * args , ** kwargs ): print ( \"hello\" ) function ( * args , ** kwargs ) print ( \"bye\" ) return wrapped_function @my_decorator def my_function ( * args , ** kwargs ): \"\"\"The function docs.\"\"\" print ( * args , ** kwargs )","title":"My wrapped function shows documentation/code for its wrapper instead of its own"},{"location":"usage/","text":"Usage \u00a4 MkDocstrings works by processing special expressions in your Markdown files. The syntax is as follow: ::: identifier YAML block The identifier is a string identifying the object you want to document. The format of an identifier can vary from one handler to another. For example, the Python handler expects the full dotted-path to a Python object: my_package.my_module.MyClass.my_method . The YAML block is optional, and contains some configuration options: handler : the name of the handler to use to collect and render this object. By default, it will use the value defined in the Global options 's default_handler key, or \"python\" . selection : a dictionary of options passed to the handler's collector. The collector is responsible for collecting the documentation from the source code. Therefore, selection options change how the documentation is collected from the source code. rendering : a dictionary of options passed to the handler's renderer. The renderer is responsible for rendering the documentation with Jinja2 templates. Therefore, rendering options affect how the selected object's documentation is rendered. Every handler accepts at least these two keys, selection and rendering , and some handlers accept additional keys. Check the documentation for your handler of interest in Handlers . Example with the Python handler docs/my_page.md # Documentation for `MyClass` ::: my_package.my_module.MyClass handler: python selection: members: - method_a - method_b rendering: show_root_heading: false show_source: false mkdocs.yml nav : - \"My page\" : my_page.md src/my_package/my_module.py class MyClass : \"\"\"Print print print!\"\"\" def method_a ( self ): \"\"\"Print A!\"\"\" print ( \"A!\" ) def method_b ( self ): \"\"\"Print B!\"\"\" print ( \"B!\" ) def method_c ( self ): \"\"\"Print C!\"\"\" print ( \"C!\" ) Result Documentation for MyClass Print print print! method_a ( self ) Print A! method_b ( self ) Print B! Global options \u00a4 MkDocstrings accept a few top-level configuration options in mkdocs.yml : watch : a list of directories to watch while serving the documentation. See Watch directories . default_handler : the handler that is used by default when no handler is specified. custom_templates : the path to a directory containing custom templates. The path is relative to the docs directory. See Customization . handlers : the handlers global configuration. Example: plugins : - mkdocstrings : default_handler : python handlers : python : rendering : show_source : false custom_templates : templates watch : - src/my_package The handlers global configuration can then be overridden by local configurations: :: : my_package.my_module.MyClass rendering : show_source : true Cross-references \u00a4 Cross-references are written as Markdown reference-style links: Markdown With a custom title: [ `Object 1` ][full.path.object1] With the identifier as title: [ full.path.object2 ][] HTML Result < p > With a custom title: < a href = \"https://site_url.com/page1#full.path.object1\" >< code > Object 1 </ code ></ a >< p > < p > With the identifier as title: < a href = \"https://site_url.com/page2#full.path.object2\" > full.path.object2 </ a ></ p > Themes \u00a4 MkDocstrings can support multiple MkDocs theme, though it only supports the Material for MkDocs theme right now. Each renderer can fallback to a particular theme when the user selected theme is not supported. For example, the Python renderer will fallback to the Material for MkDocs templates. Customization \u00a4 There is some degree of customization possible in MkDocstrings. First, you can write custom templates to override the theme templates. Second, the provided templates make use of CSS classes, so you can tweak the look and feel with extra CSS rules. Templates \u00a4 To use custom templates and override the theme ones, specify the relative path to your templates directory with the custom_templates global configuration option: # mkdocs.yml plugins : - mkdocstrings : custom_templates : templates You directory structure must be identical to the provided templates one: templates \u251c\u2500\u2500 <HANDLER 1> \u2502 \u251c\u2500\u2500 <THEME 1> \u2502 \u2514\u2500\u2500 <THEME 2> \u2514\u2500\u2500 <HANDLER 2> \u251c\u2500\u2500 <THEME 1> \u2514\u2500\u2500 <THEME 2> ( Check out the template tree on GitHub ) You don't have to replicate the whole tree, only the handlers, themes or templates you want to override. For example, to override some templates of the Material theme for Python: templates \u2514\u2500\u2500 python \u2514\u2500\u2500 material \u251c\u2500\u2500 parameters.html \u2514\u2500\u2500 exceptions.html In the HTML files, replace the original contents with your modified version. In the future, the templates will use Jinja blocks, so it will be easier to modify a small part of the template without copy-pasting the whole file. The Material theme provides the following template structure: children.html : where the recursion happen, to render all children of an object attribute.html : to render attributes (class-attributes, etc.) class.html : to render classes function.html : to render functions method.html : to render methods module.html : to render modules docstring.html : to render docstrings attributes.html : to render attributes sections of docstrings examples.html : to render examples sections of docstrings exceptions.html : to render exceptions/\"raises\" sections of docstrings parameters.html : to render parameters/arguments sections of docstrings return.html : to render \"return\" sections of docstrings properties.html : to render the properties of an object ( staticmethod , read-only , etc.) signature.html : to render functions and methods signatures CSS classes \u00a4 The Material theme uses the following CSS classes in the HTML: doc : on all the following elements doc-children : on div s containing the children of an object doc-object : on div s containing an object doc-attribute : on div s containing an attribute doc-class : on div s containing a class doc-function : on div s containing a function doc-method : on div s containing a method doc-module : on div s containing a module doc-heading : on objects headings doc-contents : on div s wrapping the docstring then the children (if any) first : same, but only on the root object's contents div doc-properties : on span s wrapping the object's properties doc-property : on small elements containing a property doc-property-PROPERTY : same, where PROPERTY is replaced by the actual property Example with colorful properties CSS . doc-property { border-radius : 15 px ; padding : 0 5 px ; } . doc-property-special { background-color : blue ; color : white ; } . doc-property-private { background-color : red ; color : white ; } . doc-property-property { background-color : green ; color : white ; } . doc-property-read-only { background-color : yellow ; color : black ; } Result .prop { border-radius: 15px; padding: 0 5px; } special private property read-only As you can see, CSS is not my field of predilection... Watch directories \u00a4 You can add directories to watch with the watch key. It accepts a list of paths. plugins : - mkdocstrings : watch : - src/my_package_1 - src/my_package_2 When serving your documentation and a change occur in one of the listed path, MkDocs will rebuild the site and reload the current page. The watch feature doesn't have special effects. Adding directories to the watch list doesn't have any other effect than watching for changes. For example, it will not tell the Python handler to look for packages in these paths (the paths are not added to the PYTHONPATH variable). If you want to tell Python where to look for packages and modules, see Python Handler: Finding modules .","title":"Usage"},{"location":"usage/#usage","text":"MkDocstrings works by processing special expressions in your Markdown files. The syntax is as follow: ::: identifier YAML block The identifier is a string identifying the object you want to document. The format of an identifier can vary from one handler to another. For example, the Python handler expects the full dotted-path to a Python object: my_package.my_module.MyClass.my_method . The YAML block is optional, and contains some configuration options: handler : the name of the handler to use to collect and render this object. By default, it will use the value defined in the Global options 's default_handler key, or \"python\" . selection : a dictionary of options passed to the handler's collector. The collector is responsible for collecting the documentation from the source code. Therefore, selection options change how the documentation is collected from the source code. rendering : a dictionary of options passed to the handler's renderer. The renderer is responsible for rendering the documentation with Jinja2 templates. Therefore, rendering options affect how the selected object's documentation is rendered. Every handler accepts at least these two keys, selection and rendering , and some handlers accept additional keys. Check the documentation for your handler of interest in Handlers . Example with the Python handler docs/my_page.md # Documentation for `MyClass` ::: my_package.my_module.MyClass handler: python selection: members: - method_a - method_b rendering: show_root_heading: false show_source: false mkdocs.yml nav : - \"My page\" : my_page.md src/my_package/my_module.py class MyClass : \"\"\"Print print print!\"\"\" def method_a ( self ): \"\"\"Print A!\"\"\" print ( \"A!\" ) def method_b ( self ): \"\"\"Print B!\"\"\" print ( \"B!\" ) def method_c ( self ): \"\"\"Print C!\"\"\" print ( \"C!\" ) Result","title":"Usage"},{"location":"usage/#global-options","text":"MkDocstrings accept a few top-level configuration options in mkdocs.yml : watch : a list of directories to watch while serving the documentation. See Watch directories . default_handler : the handler that is used by default when no handler is specified. custom_templates : the path to a directory containing custom templates. The path is relative to the docs directory. See Customization . handlers : the handlers global configuration. Example: plugins : - mkdocstrings : default_handler : python handlers : python : rendering : show_source : false custom_templates : templates watch : - src/my_package The handlers global configuration can then be overridden by local configurations: :: : my_package.my_module.MyClass rendering : show_source : true","title":"Global options"},{"location":"usage/#cross-references","text":"Cross-references are written as Markdown reference-style links: Markdown With a custom title: [ `Object 1` ][full.path.object1] With the identifier as title: [ full.path.object2 ][] HTML Result < p > With a custom title: < a href = \"https://site_url.com/page1#full.path.object1\" >< code > Object 1 </ code ></ a >< p > < p > With the identifier as title: < a href = \"https://site_url.com/page2#full.path.object2\" > full.path.object2 </ a ></ p >","title":"Cross-references"},{"location":"usage/#themes","text":"MkDocstrings can support multiple MkDocs theme, though it only supports the Material for MkDocs theme right now. Each renderer can fallback to a particular theme when the user selected theme is not supported. For example, the Python renderer will fallback to the Material for MkDocs templates.","title":"Themes"},{"location":"usage/#customization","text":"There is some degree of customization possible in MkDocstrings. First, you can write custom templates to override the theme templates. Second, the provided templates make use of CSS classes, so you can tweak the look and feel with extra CSS rules.","title":"Customization"},{"location":"usage/#templates","text":"To use custom templates and override the theme ones, specify the relative path to your templates directory with the custom_templates global configuration option: # mkdocs.yml plugins : - mkdocstrings : custom_templates : templates You directory structure must be identical to the provided templates one: templates \u251c\u2500\u2500 <HANDLER 1> \u2502 \u251c\u2500\u2500 <THEME 1> \u2502 \u2514\u2500\u2500 <THEME 2> \u2514\u2500\u2500 <HANDLER 2> \u251c\u2500\u2500 <THEME 1> \u2514\u2500\u2500 <THEME 2> ( Check out the template tree on GitHub ) You don't have to replicate the whole tree, only the handlers, themes or templates you want to override. For example, to override some templates of the Material theme for Python: templates \u2514\u2500\u2500 python \u2514\u2500\u2500 material \u251c\u2500\u2500 parameters.html \u2514\u2500\u2500 exceptions.html In the HTML files, replace the original contents with your modified version. In the future, the templates will use Jinja blocks, so it will be easier to modify a small part of the template without copy-pasting the whole file. The Material theme provides the following template structure: children.html : where the recursion happen, to render all children of an object attribute.html : to render attributes (class-attributes, etc.) class.html : to render classes function.html : to render functions method.html : to render methods module.html : to render modules docstring.html : to render docstrings attributes.html : to render attributes sections of docstrings examples.html : to render examples sections of docstrings exceptions.html : to render exceptions/\"raises\" sections of docstrings parameters.html : to render parameters/arguments sections of docstrings return.html : to render \"return\" sections of docstrings properties.html : to render the properties of an object ( staticmethod , read-only , etc.) signature.html : to render functions and methods signatures","title":"Templates"},{"location":"usage/#css-classes","text":"The Material theme uses the following CSS classes in the HTML: doc : on all the following elements doc-children : on div s containing the children of an object doc-object : on div s containing an object doc-attribute : on div s containing an attribute doc-class : on div s containing a class doc-function : on div s containing a function doc-method : on div s containing a method doc-module : on div s containing a module doc-heading : on objects headings doc-contents : on div s wrapping the docstring then the children (if any) first : same, but only on the root object's contents div doc-properties : on span s wrapping the object's properties doc-property : on small elements containing a property doc-property-PROPERTY : same, where PROPERTY is replaced by the actual property Example with colorful properties CSS . doc-property { border-radius : 15 px ; padding : 0 5 px ; } . doc-property-special { background-color : blue ; color : white ; } . doc-property-private { background-color : red ; color : white ; } . doc-property-property { background-color : green ; color : white ; } . doc-property-read-only { background-color : yellow ; color : black ; } Result .prop { border-radius: 15px; padding: 0 5px; }","title":"CSS classes"},{"location":"usage/#watch-directories","text":"You can add directories to watch with the watch key. It accepts a list of paths. plugins : - mkdocstrings : watch : - src/my_package_1 - src/my_package_2 When serving your documentation and a change occur in one of the listed path, MkDocs will rebuild the site and reload the current page. The watch feature doesn't have special effects. Adding directories to the watch list doesn't have any other effect than watching for changes. For example, it will not tell the Python handler to look for packages in these paths (the paths are not added to the PYTHONPATH variable). If you want to tell Python where to look for packages and modules, see Python Handler: Finding modules .","title":"Watch directories"},{"location":"handlers/overview/","text":"Handlers \u00a4 A handler is what makes it possible to collect and render documentation for a particular language. It is composed of a collector and a renderer. See the documentation for [ BaseHandler ][mkdocstrings.handlers.BaseHandler], [ BaseCollector ][mkdocstrings.handlers.BaseCollector] and [ BaseRenderer ][mkdocstrings.handlers.BaseRenderer]. Available handlers \u00a4 [Python][mkdocstrings.handlers.python]","title":"Overview"},{"location":"handlers/overview/#handlers","text":"A handler is what makes it possible to collect and render documentation for a particular language. It is composed of a collector and a renderer. See the documentation for [ BaseHandler ][mkdocstrings.handlers.BaseHandler], [ BaseCollector ][mkdocstrings.handlers.BaseCollector] and [ BaseRenderer ][mkdocstrings.handlers.BaseRenderer].","title":"Handlers"},{"location":"handlers/overview/#available-handlers","text":"[Python][mkdocstrings.handlers.python]","title":"Available handlers"},{"location":"handlers/python/","text":"Python handler \u00a4 Handler options \u00a4 Like every handler, the Python handler accepts the common selection and rendering options, both as global and local options. The selection options gives you control over the selection of Python objects, while the rendering options lets you change how the documentation is rendered. It also accepts these additional global-only options: Option Type Description Default setup_commands list of str Run these commands before starting the documentation collection. [] Example: setup Django before collecting documentation # mkdocs.yml plugins : - mkdocstrings : handlers : python : setup_commands : - import os - import django - os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"my_django_app.settings\") - django.setup() Important Additional options like setup_commands are used only once, when instantiating the handler the first time it is requested. This is why they are considered global-only options, as they will have no effect if used as local options. Selection \u00a4 The following options are directly passed to the handler's collector. See Collector: pytkdocs to learn more about pytkdocs . Option Type Description Default filters list of str List of filtering regular expressions. Prefix with ! to exclude objects whose name match. The default means exclude private members . [\"!^_[^_]\"] members bool , or list of str Explicitly select members. True means all , false means none . True inherited_members bool Also select members inherited from parent classes. False docstring_style str Docstring style to parse. pytkdocs only supports google yet. \"google\" docstring_options dict Options to pass to the docstring parser. See Collector: pytkdocs {} Configuration example Global # mkdocs.yml plugins : - mkdocstrings : handlers : python : selection : filters : - \"!^_\" # exlude all members starting with _ - \"^__init__$\" # but always include __init__ modules and methods Local :: : my_package selection : filters : [] # pick up everything Rendering \u00a4 These options affect how the documentation is rendered. Option Type Description Default show_root_heading bool Show the heading of the object at the root of the documentation tree. False show_root_toc_entry bool If the root heading is not shown, at least add a ToC entry for it. True show_root_full_path bool Show the full Python path for the root object heading. True show_object_full_path bool Show the full Python path of every object. False show_category_heading bool When grouped by categories, show a heading for each category. False show_if_no_docstring bool Show the object heading even if it has no docstring or children with docstrings. False show_source bool Show the source code of this object. True group_by_category bool Group the object's children by categories: attributes, classes, functions, methods, and modules. True heading_level int The initial heading level to use. 2 Configuration example Global # mkdocs.yml plugins : - mkdocstrings : handlers : python : rendering : show_root_heading : yes Local ## `ClassA` ::: my_package.my_module.ClassA rendering: show_root_heading: no heading_level: 3 Collector: pytkdocs \u00a4 The tool used by the Python handler to collect documentation from Python source code is pytkdocs . It stands for (Python) Take Docs , and is supposed to be a pun on MkDocs ( Make Docs ?). Supported docstrings styles \u00a4 Right now, pytkdocs supports only the Google-style docstring format. Google-style \u00a4 You can see examples of Google-style docstrings in Napoleon's documentation . Sections \u00a4 Docstrings sections are parsed by pytkdocs and rendered by MkDocstrings. Supported sections are: Arguments (or Args , Parameters , Params ) Attributes Examples (or Example ) Raises (or Raise , Except , Exceptions ) Returns (or Return ) Admonitions \u00a4 Additionally, any section that is not recognized will be transformed into its admonition equivalent. For example: Original \"\"\" Note: You can disable this behavior with the `replace_admonitions` option. To prevent `pytkdocs` from converting sections to admonitions, use the `replace_admonitions`: ```md ::: my_package.my_module selection: docstring_style: google # this is the default docstring_options: replace_admonitions: no ``` So meta! \"\"\" Modified \"\"\" !!! note \"You can disable this behavior with the `replace_admonitions` option.\" To prevent `pytkdocs` from converting sections to admonitions, use the `replace_admonitions`: ```md ::: my_package.my_module selection: docstring_style: google # this is the default docstring_options: replace_admonitions: no ``` So meta! \"\"\" Result You can disable this behavior with the replace_admonitions parser option. To prevent pytkdocs from converting sections to admonitions, use the replace_admonitions parser option: ::: my_package.my_module selection: docstring_style: google # this is the default docstring_options: replace_admonitions: no So meta! As shown in the above example, this can be disabled with the replace_admonitions option of the Google-style parser: :: : my_package.my_module selection : docstring_style : google # this is the default docstring_options : replace_admonitions : no Annotations \u00a4 Type annotations are read both in the code and in the docstrings. Example with a function Expand the source at the end to see the original code! A short description of this function. Parameters: Name Type Description Default param1 int An integer? required param2 Optional[str] A string? If you have a long description, you can split it on multiple lines. Just remember to indent those lines consistently. Complex markup is supported in sections items. I'm a code block! None Source code in snippets/function_annotations.py def my_function ( param1 : int , param2 : Optional [ str ] = None ) -> str : \"\"\" A short description of this function. Arguments: param1: An integer? param2: A string? If you have a long description, you can split it on multiple lines. Just remember to indent those lines consistently. Complex markup is supported in sections items. I'm a code block! \"\"\" return f \" { param2 }{ param1 } \" Finding modules \u00a4 In order for pytkdocs to find your packages and modules, you should take advantage of the usual Python loading mechanisms: install your package in the current virtualenv: . venv/bin/activate pip install -e . poetry install ...etc. or add your package(s) parent directory in the PYTHONPATH . ( The following instructions assume your Python package is in the src directory. ) In Bash and other shells, you can run your command like this (note the prepended PYTHONPATH=... ): PYTHONPATH = src poetry run mkdocs serve You could also export that variable, but this is not recommended as it could affect other Python processes: export PYTHONPATH = src # Linux/Bash and similar setx PYTHONPATH src # Windows, USE AT YOUR OWN RISKS You can also use the Python handler setup_commands : # mkdocs.yml plugins : - mkdocstrings : handlers : python : setup_commands : - import sys - sys.path.append(\"src\") # or sys.path.insert(0, \"src\") Mocking libraries \u00a4 You may want to to generate documentation for a package while its dependencies are not available. The Python handler provides itself no builtin way to mock libraries, but you can use the setup_commands to mock them manually: # mkdocs.yml plugins : - mkdocstrings : handlers : python : setup_commands : - import sys - from unittest.mock import MagicMock as mock - sys.modules[\"lib1\"] = mock() - sys.modules[\"lib2\"] = mock() - sys.modules[\"lib2.module1\"] = mock() - sys.modules[\"lib2.module1.moduleB\"] = mock() # etc Recommended style (Material) \u00a4 Here are some CSS rules for the Material for MkDocs theme: /* Indentation. */ div . doc-contents : not ( . first ) { padding-left : 25 px ; border-left : 4 px solid rgba ( 230 , 230 , 230 ); margin-bottom : 80 px ; } /* Don't capitalize names. */ h5 . doc-heading { text-transform : none !important ; } /* Don't use vertical space on hidden ToC entries. */ h6 . hidden-toc { margin : 0 !important ; position : relative ; top : -70 px ; } h6 . hidden-toc :: before { margin-top : 0 !important ; padding-top : 0 !important ; } /* Don't show permalink of hidden ToC entries. */ h6 . hidden-toc a . headerlink { display : none ; } /* Avoid breaking parameters name, etc. in table cells. */ td code { word-break : normal !important ; } /* For pieces of Markdown rendered in table cells. */ td p { margin-top : 0 !important ; margin-bottom : 0 !important ; }","title":"Python"},{"location":"handlers/python/#python-handler","text":"","title":"Python handler"},{"location":"handlers/python/#handler-options","text":"Like every handler, the Python handler accepts the common selection and rendering options, both as global and local options. The selection options gives you control over the selection of Python objects, while the rendering options lets you change how the documentation is rendered. It also accepts these additional global-only options: Option Type Description Default setup_commands list of str Run these commands before starting the documentation collection. [] Example: setup Django before collecting documentation # mkdocs.yml plugins : - mkdocstrings : handlers : python : setup_commands : - import os - import django - os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"my_django_app.settings\") - django.setup() Important Additional options like setup_commands are used only once, when instantiating the handler the first time it is requested. This is why they are considered global-only options, as they will have no effect if used as local options.","title":"Handler options"},{"location":"handlers/python/#selection","text":"The following options are directly passed to the handler's collector. See Collector: pytkdocs to learn more about pytkdocs . Option Type Description Default filters list of str List of filtering regular expressions. Prefix with ! to exclude objects whose name match. The default means exclude private members . [\"!^_[^_]\"] members bool , or list of str Explicitly select members. True means all , false means none . True inherited_members bool Also select members inherited from parent classes. False docstring_style str Docstring style to parse. pytkdocs only supports google yet. \"google\" docstring_options dict Options to pass to the docstring parser. See Collector: pytkdocs {} Configuration example Global # mkdocs.yml plugins : - mkdocstrings : handlers : python : selection : filters : - \"!^_\" # exlude all members starting with _ - \"^__init__$\" # but always include __init__ modules and methods Local :: : my_package selection : filters : [] # pick up everything","title":"Selection"},{"location":"handlers/python/#rendering","text":"These options affect how the documentation is rendered. Option Type Description Default show_root_heading bool Show the heading of the object at the root of the documentation tree. False show_root_toc_entry bool If the root heading is not shown, at least add a ToC entry for it. True show_root_full_path bool Show the full Python path for the root object heading. True show_object_full_path bool Show the full Python path of every object. False show_category_heading bool When grouped by categories, show a heading for each category. False show_if_no_docstring bool Show the object heading even if it has no docstring or children with docstrings. False show_source bool Show the source code of this object. True group_by_category bool Group the object's children by categories: attributes, classes, functions, methods, and modules. True heading_level int The initial heading level to use. 2 Configuration example Global # mkdocs.yml plugins : - mkdocstrings : handlers : python : rendering : show_root_heading : yes Local ## `ClassA` ::: my_package.my_module.ClassA rendering: show_root_heading: no heading_level: 3","title":"Rendering"},{"location":"handlers/python/#collector-pytkdocs","text":"The tool used by the Python handler to collect documentation from Python source code is pytkdocs . It stands for (Python) Take Docs , and is supposed to be a pun on MkDocs ( Make Docs ?).","title":"Collector: pytkdocs"},{"location":"handlers/python/#supported-docstrings-styles","text":"Right now, pytkdocs supports only the Google-style docstring format.","title":"Supported docstrings styles"},{"location":"handlers/python/#google-style","text":"You can see examples of Google-style docstrings in Napoleon's documentation .","title":"Google-style"},{"location":"handlers/python/#sections","text":"Docstrings sections are parsed by pytkdocs and rendered by MkDocstrings. Supported sections are: Arguments (or Args , Parameters , Params ) Attributes Examples (or Example ) Raises (or Raise , Except , Exceptions ) Returns (or Return )","title":"Sections"},{"location":"handlers/python/#admonitions","text":"Additionally, any section that is not recognized will be transformed into its admonition equivalent. For example: Original \"\"\" Note: You can disable this behavior with the `replace_admonitions` option. To prevent `pytkdocs` from converting sections to admonitions, use the `replace_admonitions`: ```md ::: my_package.my_module selection: docstring_style: google # this is the default docstring_options: replace_admonitions: no ``` So meta! \"\"\" Modified \"\"\" !!! note \"You can disable this behavior with the `replace_admonitions` option.\" To prevent `pytkdocs` from converting sections to admonitions, use the `replace_admonitions`: ```md ::: my_package.my_module selection: docstring_style: google # this is the default docstring_options: replace_admonitions: no ``` So meta! \"\"\" Result You can disable this behavior with the replace_admonitions parser option. To prevent pytkdocs from converting sections to admonitions, use the replace_admonitions parser option: ::: my_package.my_module selection: docstring_style: google # this is the default docstring_options: replace_admonitions: no So meta! As shown in the above example, this can be disabled with the replace_admonitions option of the Google-style parser: :: : my_package.my_module selection : docstring_style : google # this is the default docstring_options : replace_admonitions : no","title":"Admonitions"},{"location":"handlers/python/#annotations","text":"Type annotations are read both in the code and in the docstrings. Example with a function Expand the source at the end to see the original code! A short description of this function. Parameters: Name Type Description Default param1 int An integer? required param2 Optional[str] A string? If you have a long description, you can split it on multiple lines. Just remember to indent those lines consistently. Complex markup is supported in sections items. I'm a code block! None Source code in snippets/function_annotations.py def my_function ( param1 : int , param2 : Optional [ str ] = None ) -> str : \"\"\" A short description of this function. Arguments: param1: An integer? param2: A string? If you have a long description, you can split it on multiple lines. Just remember to indent those lines consistently. Complex markup is supported in sections items. I'm a code block! \"\"\" return f \" { param2 }{ param1 } \"","title":"Annotations"},{"location":"handlers/python/#finding-modules","text":"In order for pytkdocs to find your packages and modules, you should take advantage of the usual Python loading mechanisms: install your package in the current virtualenv: . venv/bin/activate pip install -e . poetry install ...etc. or add your package(s) parent directory in the PYTHONPATH . ( The following instructions assume your Python package is in the src directory. ) In Bash and other shells, you can run your command like this (note the prepended PYTHONPATH=... ): PYTHONPATH = src poetry run mkdocs serve You could also export that variable, but this is not recommended as it could affect other Python processes: export PYTHONPATH = src # Linux/Bash and similar setx PYTHONPATH src # Windows, USE AT YOUR OWN RISKS You can also use the Python handler setup_commands : # mkdocs.yml plugins : - mkdocstrings : handlers : python : setup_commands : - import sys - sys.path.append(\"src\") # or sys.path.insert(0, \"src\")","title":"Finding modules"},{"location":"handlers/python/#mocking-libraries","text":"You may want to to generate documentation for a package while its dependencies are not available. The Python handler provides itself no builtin way to mock libraries, but you can use the setup_commands to mock them manually: # mkdocs.yml plugins : - mkdocstrings : handlers : python : setup_commands : - import sys - from unittest.mock import MagicMock as mock - sys.modules[\"lib1\"] = mock() - sys.modules[\"lib2\"] = mock() - sys.modules[\"lib2.module1\"] = mock() - sys.modules[\"lib2.module1.moduleB\"] = mock() # etc","title":"Mocking libraries"},{"location":"handlers/python/#recommended-style-material","text":"Here are some CSS rules for the Material for MkDocs theme: /* Indentation. */ div . doc-contents : not ( . first ) { padding-left : 25 px ; border-left : 4 px solid rgba ( 230 , 230 , 230 ); margin-bottom : 80 px ; } /* Don't capitalize names. */ h5 . doc-heading { text-transform : none !important ; } /* Don't use vertical space on hidden ToC entries. */ h6 . hidden-toc { margin : 0 !important ; position : relative ; top : -70 px ; } h6 . hidden-toc :: before { margin-top : 0 !important ; padding-top : 0 !important ; } /* Don't show permalink of hidden ToC entries. */ h6 . hidden-toc a . headerlink { display : none ; } /* Avoid breaking parameters name, etc. in table cells. */ td code { word-break : normal !important ; } /* For pieces of Markdown rendered in table cells. */ td p { margin-top : 0 !important ; margin-bottom : 0 !important ; }","title":"Recommended style (Material)"},{"location":"reference/extension/","text":"\u00a4 This module holds the code of the Markdown extension responsible for matching \"autodoc\" instructions. The extension is composed of a Markdown block processor that matches indented blocks starting with a line like '::: identifier'. For each of these blocks, it uses a [handler][mkdocstrings.handlers.BaseHandler] to collect documentation about the given identifier and render it with Jinja templates. Both the collection and rendering process can be configured by adding YAML configuration under the \"autodoc\" instruction: :: : some.identifier handler : python selection : option1 : value1 option2 : - value2a - value2b rendering : option_x : etc AutoDocProcessor \u00a4 Our \"autodoc\" Markdown block processor. It has a [ test method][mkdocstrings.extension.AutoDocProcessor.test] that tells if a block matches a criterion, and a [ run method][mkdocstrings.extension.AutoDocProcessor.run] that processes it. It also has utility methods allowing to get handlers and their configuration easily, useful when processing a matched block. __init__ ( self , parser , md , config ) special \u00a4 Initialize the object. Parameters: Name Type Description Default parser BlockParser A markdown.blockparser.BlockParser instance. required md Markdown A markdown.Markdown instance. required config dict The [configuration][mkdocstrings.plugin.MkdocstringsPlugin.config_scheme] of the mkdocstrings plugin. required Source code in mkdocstrings/extension.py def __init__ ( self , parser : BlockParser , md : Markdown , config : dict ) -> None : \"\"\" Initialize the object. Arguments: parser: A `markdown.blockparser.BlockParser` instance. md: A `markdown.Markdown` instance. config: The [configuration][mkdocstrings.plugin.MkdocstringsPlugin.config_scheme] of the `mkdocstrings` plugin. \"\"\" super () . __init__ ( parser = parser ) self . md = md self . _config = config get_handler_config ( self , handler_name ) \u00a4 Return the global configuration of the given handler. Parameters: Name Type Description Default handler_name str The name of the handler to get the global configuration of. required Returns: Type Description dict The global configuration of the given handler. It can be an empty dictionary. Source code in mkdocstrings/extension.py def get_handler_config ( self , handler_name : str ) -> dict : \"\"\" Return the global configuration of the given handler. Arguments: handler_name: The name of the handler to get the global configuration of. Returns: The global configuration of the given handler. It can be an empty dictionary. \"\"\" handlers = self . _config [ \"mkdocstrings\" ] . get ( \"handlers\" , {}) if handlers : return handlers . get ( handler_name , {}) return {} get_handler_name ( self , config ) \u00a4 Return the handler name defined in an \"autodoc\" instruction YAML configuration, or the global default handler. Parameters: Name Type Description Default config dict A configuration dictionary, obtained from YAML below the \"autodoc\" instruction. required Returns: Type Description str The name of the handler to use. Source code in mkdocstrings/extension.py def get_handler_name ( self , config : dict ) -> str : \"\"\" Return the handler name defined in an \"autodoc\" instruction YAML configuration, or the global default handler. Arguments: config: A configuration dictionary, obtained from YAML below the \"autodoc\" instruction. Returns: The name of the handler to use. \"\"\" if \"handler\" in config : return config [ \"handler\" ] return self . _config [ \"mkdocstrings\" ][ \"default_handler\" ] process_block ( self , identifier , yaml_block ) \u00a4 Process an autodoc block. Parameters: Name Type Description Default identifier str The identifier of the object to collect and render. required yaml_block str The YAML configuration. required Exceptions: Type Description CollectionError When something wrong happened during collection. Returns: Type Description Element A new XML element. Source code in mkdocstrings/extension.py def process_block ( self , identifier : str , yaml_block : str ) -> Element : \"\"\" Process an autodoc block. Arguments: identifier: The identifier of the object to collect and render. yaml_block: The YAML configuration. Raises: CollectionError: When something wrong happened during collection. Returns: A new XML element. \"\"\" config = yaml . safe_load ( yaml_block ) or {} handler_name = self . get_handler_name ( config ) log . debug ( f \"mkdocstrings.extension: Using handler ' { handler_name } '\" ) handler_config = self . get_handler_config ( handler_name ) handler = get_handler ( handler_name , self . _config [ \"theme_name\" ], self . _config [ \"mkdocstrings\" ][ \"custom_templates\" ], ** handler_config , ) selection , rendering = get_item_configs ( handler_config , config ) log . debug ( \"mkdocstrings.extension: Collecting data\" ) try : data : Any = handler . collector . collect ( identifier , selection ) except CollectionError : log . error ( f \"mkdocstrings.extension: Could not collect ' { identifier } '\" ) raise log . debug ( \"mkdocstrings.extension: Updating renderer's env\" ) handler . renderer . update_env ( self . md , self . _config ) log . debug ( \"mkdocstrings.extension: Rendering templates\" ) try : rendered = handler . renderer . render ( data , rendering ) except TemplateNotFound as exc : theme_name = self . _config [ \"theme_name\" ] log . error ( f \"mkdocstrings.extension: Template ' { exc . name } ' not found \" f \"for ' { handler_name } ' handler and theme ' { theme_name } '.\" , ) raise log . debug ( \"mkdocstrings.extension: Loading HTML back into XML tree\" ) try : xml_contents = XML ( ENTITIES + rendered ) except ParseError as error : log_xml_parse_error ( str ( error ), rendered ) raise return atomic_brute_cast ( xml_contents ) # type: ignore run ( self , parent , blocks ) \u00a4 Run code on the matched blocks. The identifier and configuration lines are retrieved from a matched block and used to collect and render an object. Parameters: Name Type Description Default parent Element The parent element in the XML tree. required blocks Element The rest of the blocks to be processed. required Source code in mkdocstrings/extension.py def run ( self , parent : Element , blocks : Element ) -> None : \"\"\" Run code on the matched blocks. The identifier and configuration lines are retrieved from a matched block and used to collect and render an object. Arguments: parent: The parent element in the XML tree. blocks: The rest of the blocks to be processed. \"\"\" block = blocks . pop ( 0 ) match = self . regex . search ( str ( block )) if match : # removes the first line block = block [ match . end () :] # type: ignore block , the_rest = self . detab ( block ) if match : identifier = match . group ( 1 ) log . debug ( f \"mkdocstrings.extension: Matched '::: { identifier } '\" ) xml_element = self . process_block ( identifier , str ( block )) parent . append ( xml_element ) if the_rest : # This block contained unindented line(s) after the first indented # line. Insert these lines as the first block of the master blocks # list for future processing. blocks . insert ( 0 , the_rest ) test ( self , parent , block ) \u00a4 Match our autodoc instructions. Parameters: Name Type Description Default parent Element parent: The parent element in the XML tree. required block Element The block to be tested. required Returns: Type Description bool Whether this block should be processed or not. Source code in mkdocstrings/extension.py def test ( self , parent : Element , block : Element ) -> bool : \"\"\" Match our autodoc instructions. Arguments: parent:parent: The parent element in the XML tree. block: The block to be tested. Returns: Whether this block should be processed or not. \"\"\" sibling = self . lastChild ( parent ) bool1 = self . regex . search ( str ( block )) bool2 = ( str ( block ) . startswith ( \" \" * self . tab_length ) and sibling is not None and sibling . get ( \"class\" , \"\" ) . find ( self . classname ) != - 1 ) return bool ( bool1 or bool2 ) MkdocstringsExtension \u00a4 Our Markdown extension. It cannot work outside of mkdocstrings . __init__ ( self , config , ** kwargs ) special \u00a4 Initialize the object. Parameters: Name Type Description Default config dict The configuration items from mkdocs and mkdocstrings that must be passed to the block processor when instantiated in [ extendMarkdown ][mkdocstrings.extension.MkdocstringsExtension.extendMarkdown]. required kwargs Keyword arguments used by markdown.extensions.Extension . {} Source code in mkdocstrings/extension.py def __init__ ( self , config : dict , ** kwargs ) -> None : \"\"\" Initialize the object. Arguments: config: The configuration items from `mkdocs` and `mkdocstrings` that must be passed to the block processor when instantiated in [`extendMarkdown`][mkdocstrings.extension.MkdocstringsExtension.extendMarkdown]. kwargs: Keyword arguments used by `markdown.extensions.Extension`. \"\"\" super () . __init__ ( ** kwargs ) self . _config = config extendMarkdown ( self , md ) \u00a4 Register the extension. Add an instance of our [ AutoDocProcessor ][mkdocstrings.extension.AutoDocProcessor] to the Markdown parser. Parameters: Name Type Description Default md Markdown A markdown.Markdown instance. required Source code in mkdocstrings/extension.py def extendMarkdown ( self , md : Markdown ) -> None : # noqa: N802 (casing: parent method's name) \"\"\" Register the extension. Add an instance of our [`AutoDocProcessor`][mkdocstrings.extension.AutoDocProcessor] to the Markdown parser. Arguments: md: A `markdown.Markdown` instance. \"\"\" md . registerExtension ( self ) processor = AutoDocProcessor ( md . parser , md , self . _config ) md . parser . blockprocessors . register ( processor , \"mkdocstrings\" , self . priority ) atomic_brute_cast ( tree ) \u00a4 Cast every node's text into an atomic string to prevent further processing on it. Since we generate the final HTML with Jinja templates, we do not want other inline or tree processors to keep modifying the data, so this function is used to mark the complete tree as \"do not touch\". Reference: issue Python-Markdown/markdown#920 . On a side note: isn't atomic_brute_cast such a beautiful function name? Parameters: Name Type Description Default tree Element An XML node, used like the root of an XML tree. required Returns: Type Description Element The same node, recursively modified by side-effect. You can skip re-assigning the return value. Source code in mkdocstrings/extension.py def atomic_brute_cast ( tree : Element ) -> Element : \"\"\" Cast every node's text into an atomic string to prevent further processing on it. Since we generate the final HTML with Jinja templates, we do not want other inline or tree processors to keep modifying the data, so this function is used to mark the complete tree as \"do not touch\". Reference: issue [Python-Markdown/markdown#920](https://github.com/Python-Markdown/markdown/issues/920). On a side note: isn't `atomic_brute_cast` such a beautiful function name? Arguments: tree: An XML node, used like the root of an XML tree. Returns: The same node, recursively modified by side-effect. You can skip re-assigning the return value. \"\"\" if tree . text : tree . text = AtomicString ( tree . text ) for child in tree : atomic_brute_cast ( child ) return tree get_item_configs ( handler_config , config ) \u00a4 Get the selection and rendering configuration merged into the global configuration of the given handler. Parameters: Name Type Description Default handler_config dict The global configuration of a handler. It can be an empty dictionary. required config dict The configuration to merge into the global handler configuration. required Returns: Type Description Tuple[dict, dict] Two dictionaries: selection and rendering. The local configurations are merged into the global ones. Source code in mkdocstrings/extension.py def get_item_configs ( handler_config : dict , config : dict ) -> Tuple [ dict , dict ]: \"\"\" Get the selection and rendering configuration merged into the global configuration of the given handler. Arguments: handler_config: The global configuration of a handler. It can be an empty dictionary. config: The configuration to merge into the global handler configuration. Returns: Two dictionaries: selection and rendering. The local configurations are merged into the global ones. \"\"\" item_selection_config = dict ( handler_config . get ( \"selection\" , {})) item_selection_config . update ( config . get ( \"selection\" , {})) item_rendering_config = dict ( handler_config . get ( \"rendering\" , {})) item_rendering_config . update ( config . get ( \"rendering\" , {})) return item_selection_config , item_rendering_config log_xml_parse_error ( error , xml_text ) \u00a4 Log an XML parsing error. If the error is a tag mismatch, augment the log message. Parameters: Name Type Description Default error str The error message (no traceback). required xml_text str The XML text that generated the parsing error. required Source code in mkdocstrings/extension.py def log_xml_parse_error ( error : str , xml_text : str ) -> None : \"\"\" Log an XML parsing error. If the error is a tag mismatch, augment the log message. Arguments: error: The error message (no traceback). xml_text: The XML text that generated the parsing error. \"\"\" message = f \"mkdocstrings.extension: { error } \" if \"mismatched tag\" in error : line_column = error [ error . rfind ( \":\" ) + 1 :] line , column = line_column . split ( \", \" ) lineno = int ( line [ line . rfind ( \" \" ) + 1 :]) columnno = int ( column [ column . rfind ( \" \" ) + 1 :]) line = xml_text . split ( \" \\n \" )[ lineno - 1 ] character = line [ columnno ] message += ( f \" (character { character } ): \\n { line } \\n \" \"If your Markdown contains angle brackets < >, try to wrap them between backticks `< >`, \" \"or replace them with < and >\" ) log . error ( message )","title":"extension.py"},{"location":"reference/extension/#mkdocstrings.extension","text":"This module holds the code of the Markdown extension responsible for matching \"autodoc\" instructions. The extension is composed of a Markdown block processor that matches indented blocks starting with a line like '::: identifier'. For each of these blocks, it uses a [handler][mkdocstrings.handlers.BaseHandler] to collect documentation about the given identifier and render it with Jinja templates. Both the collection and rendering process can be configured by adding YAML configuration under the \"autodoc\" instruction: :: : some.identifier handler : python selection : option1 : value1 option2 : - value2a - value2b rendering : option_x : etc","title":"mkdocstrings.extension"},{"location":"reference/extension/#mkdocstrings.extension.AutoDocProcessor","text":"Our \"autodoc\" Markdown block processor. It has a [ test method][mkdocstrings.extension.AutoDocProcessor.test] that tells if a block matches a criterion, and a [ run method][mkdocstrings.extension.AutoDocProcessor.run] that processes it. It also has utility methods allowing to get handlers and their configuration easily, useful when processing a matched block.","title":"AutoDocProcessor"},{"location":"reference/extension/#mkdocstrings.extension.AutoDocProcessor.__init__","text":"Initialize the object. Parameters: Name Type Description Default parser BlockParser A markdown.blockparser.BlockParser instance. required md Markdown A markdown.Markdown instance. required config dict The [configuration][mkdocstrings.plugin.MkdocstringsPlugin.config_scheme] of the mkdocstrings plugin. required Source code in mkdocstrings/extension.py def __init__ ( self , parser : BlockParser , md : Markdown , config : dict ) -> None : \"\"\" Initialize the object. Arguments: parser: A `markdown.blockparser.BlockParser` instance. md: A `markdown.Markdown` instance. config: The [configuration][mkdocstrings.plugin.MkdocstringsPlugin.config_scheme] of the `mkdocstrings` plugin. \"\"\" super () . __init__ ( parser = parser ) self . md = md self . _config = config","title":"__init__()"},{"location":"reference/extension/#mkdocstrings.extension.AutoDocProcessor.get_handler_config","text":"Return the global configuration of the given handler. Parameters: Name Type Description Default handler_name str The name of the handler to get the global configuration of. required Returns: Type Description dict The global configuration of the given handler. It can be an empty dictionary. Source code in mkdocstrings/extension.py def get_handler_config ( self , handler_name : str ) -> dict : \"\"\" Return the global configuration of the given handler. Arguments: handler_name: The name of the handler to get the global configuration of. Returns: The global configuration of the given handler. It can be an empty dictionary. \"\"\" handlers = self . _config [ \"mkdocstrings\" ] . get ( \"handlers\" , {}) if handlers : return handlers . get ( handler_name , {}) return {}","title":"get_handler_config()"},{"location":"reference/extension/#mkdocstrings.extension.AutoDocProcessor.get_handler_name","text":"Return the handler name defined in an \"autodoc\" instruction YAML configuration, or the global default handler. Parameters: Name Type Description Default config dict A configuration dictionary, obtained from YAML below the \"autodoc\" instruction. required Returns: Type Description str The name of the handler to use. Source code in mkdocstrings/extension.py def get_handler_name ( self , config : dict ) -> str : \"\"\" Return the handler name defined in an \"autodoc\" instruction YAML configuration, or the global default handler. Arguments: config: A configuration dictionary, obtained from YAML below the \"autodoc\" instruction. Returns: The name of the handler to use. \"\"\" if \"handler\" in config : return config [ \"handler\" ] return self . _config [ \"mkdocstrings\" ][ \"default_handler\" ]","title":"get_handler_name()"},{"location":"reference/extension/#mkdocstrings.extension.AutoDocProcessor.process_block","text":"Process an autodoc block. Parameters: Name Type Description Default identifier str The identifier of the object to collect and render. required yaml_block str The YAML configuration. required Exceptions: Type Description CollectionError When something wrong happened during collection. Returns: Type Description Element A new XML element. Source code in mkdocstrings/extension.py def process_block ( self , identifier : str , yaml_block : str ) -> Element : \"\"\" Process an autodoc block. Arguments: identifier: The identifier of the object to collect and render. yaml_block: The YAML configuration. Raises: CollectionError: When something wrong happened during collection. Returns: A new XML element. \"\"\" config = yaml . safe_load ( yaml_block ) or {} handler_name = self . get_handler_name ( config ) log . debug ( f \"mkdocstrings.extension: Using handler ' { handler_name } '\" ) handler_config = self . get_handler_config ( handler_name ) handler = get_handler ( handler_name , self . _config [ \"theme_name\" ], self . _config [ \"mkdocstrings\" ][ \"custom_templates\" ], ** handler_config , ) selection , rendering = get_item_configs ( handler_config , config ) log . debug ( \"mkdocstrings.extension: Collecting data\" ) try : data : Any = handler . collector . collect ( identifier , selection ) except CollectionError : log . error ( f \"mkdocstrings.extension: Could not collect ' { identifier } '\" ) raise log . debug ( \"mkdocstrings.extension: Updating renderer's env\" ) handler . renderer . update_env ( self . md , self . _config ) log . debug ( \"mkdocstrings.extension: Rendering templates\" ) try : rendered = handler . renderer . render ( data , rendering ) except TemplateNotFound as exc : theme_name = self . _config [ \"theme_name\" ] log . error ( f \"mkdocstrings.extension: Template ' { exc . name } ' not found \" f \"for ' { handler_name } ' handler and theme ' { theme_name } '.\" , ) raise log . debug ( \"mkdocstrings.extension: Loading HTML back into XML tree\" ) try : xml_contents = XML ( ENTITIES + rendered ) except ParseError as error : log_xml_parse_error ( str ( error ), rendered ) raise return atomic_brute_cast ( xml_contents ) # type: ignore","title":"process_block()"},{"location":"reference/extension/#mkdocstrings.extension.AutoDocProcessor.run","text":"Run code on the matched blocks. The identifier and configuration lines are retrieved from a matched block and used to collect and render an object. Parameters: Name Type Description Default parent Element The parent element in the XML tree. required blocks Element The rest of the blocks to be processed. required Source code in mkdocstrings/extension.py def run ( self , parent : Element , blocks : Element ) -> None : \"\"\" Run code on the matched blocks. The identifier and configuration lines are retrieved from a matched block and used to collect and render an object. Arguments: parent: The parent element in the XML tree. blocks: The rest of the blocks to be processed. \"\"\" block = blocks . pop ( 0 ) match = self . regex . search ( str ( block )) if match : # removes the first line block = block [ match . end () :] # type: ignore block , the_rest = self . detab ( block ) if match : identifier = match . group ( 1 ) log . debug ( f \"mkdocstrings.extension: Matched '::: { identifier } '\" ) xml_element = self . process_block ( identifier , str ( block )) parent . append ( xml_element ) if the_rest : # This block contained unindented line(s) after the first indented # line. Insert these lines as the first block of the master blocks # list for future processing. blocks . insert ( 0 , the_rest )","title":"run()"},{"location":"reference/extension/#mkdocstrings.extension.AutoDocProcessor.test","text":"Match our autodoc instructions. Parameters: Name Type Description Default parent Element parent: The parent element in the XML tree. required block Element The block to be tested. required Returns: Type Description bool Whether this block should be processed or not. Source code in mkdocstrings/extension.py def test ( self , parent : Element , block : Element ) -> bool : \"\"\" Match our autodoc instructions. Arguments: parent:parent: The parent element in the XML tree. block: The block to be tested. Returns: Whether this block should be processed or not. \"\"\" sibling = self . lastChild ( parent ) bool1 = self . regex . search ( str ( block )) bool2 = ( str ( block ) . startswith ( \" \" * self . tab_length ) and sibling is not None and sibling . get ( \"class\" , \"\" ) . find ( self . classname ) != - 1 ) return bool ( bool1 or bool2 )","title":"test()"},{"location":"reference/extension/#mkdocstrings.extension.MkdocstringsExtension","text":"Our Markdown extension. It cannot work outside of mkdocstrings .","title":"MkdocstringsExtension"},{"location":"reference/extension/#mkdocstrings.extension.MkdocstringsExtension.__init__","text":"Initialize the object. Parameters: Name Type Description Default config dict The configuration items from mkdocs and mkdocstrings that must be passed to the block processor when instantiated in [ extendMarkdown ][mkdocstrings.extension.MkdocstringsExtension.extendMarkdown]. required kwargs Keyword arguments used by markdown.extensions.Extension . {} Source code in mkdocstrings/extension.py def __init__ ( self , config : dict , ** kwargs ) -> None : \"\"\" Initialize the object. Arguments: config: The configuration items from `mkdocs` and `mkdocstrings` that must be passed to the block processor when instantiated in [`extendMarkdown`][mkdocstrings.extension.MkdocstringsExtension.extendMarkdown]. kwargs: Keyword arguments used by `markdown.extensions.Extension`. \"\"\" super () . __init__ ( ** kwargs ) self . _config = config","title":"__init__()"},{"location":"reference/extension/#mkdocstrings.extension.MkdocstringsExtension.extendMarkdown","text":"Register the extension. Add an instance of our [ AutoDocProcessor ][mkdocstrings.extension.AutoDocProcessor] to the Markdown parser. Parameters: Name Type Description Default md Markdown A markdown.Markdown instance. required Source code in mkdocstrings/extension.py def extendMarkdown ( self , md : Markdown ) -> None : # noqa: N802 (casing: parent method's name) \"\"\" Register the extension. Add an instance of our [`AutoDocProcessor`][mkdocstrings.extension.AutoDocProcessor] to the Markdown parser. Arguments: md: A `markdown.Markdown` instance. \"\"\" md . registerExtension ( self ) processor = AutoDocProcessor ( md . parser , md , self . _config ) md . parser . blockprocessors . register ( processor , \"mkdocstrings\" , self . priority )","title":"extendMarkdown()"},{"location":"reference/extension/#mkdocstrings.extension.atomic_brute_cast","text":"Cast every node's text into an atomic string to prevent further processing on it. Since we generate the final HTML with Jinja templates, we do not want other inline or tree processors to keep modifying the data, so this function is used to mark the complete tree as \"do not touch\". Reference: issue Python-Markdown/markdown#920 . On a side note: isn't atomic_brute_cast such a beautiful function name? Parameters: Name Type Description Default tree Element An XML node, used like the root of an XML tree. required Returns: Type Description Element The same node, recursively modified by side-effect. You can skip re-assigning the return value. Source code in mkdocstrings/extension.py def atomic_brute_cast ( tree : Element ) -> Element : \"\"\" Cast every node's text into an atomic string to prevent further processing on it. Since we generate the final HTML with Jinja templates, we do not want other inline or tree processors to keep modifying the data, so this function is used to mark the complete tree as \"do not touch\". Reference: issue [Python-Markdown/markdown#920](https://github.com/Python-Markdown/markdown/issues/920). On a side note: isn't `atomic_brute_cast` such a beautiful function name? Arguments: tree: An XML node, used like the root of an XML tree. Returns: The same node, recursively modified by side-effect. You can skip re-assigning the return value. \"\"\" if tree . text : tree . text = AtomicString ( tree . text ) for child in tree : atomic_brute_cast ( child ) return tree","title":"atomic_brute_cast()"},{"location":"reference/extension/#mkdocstrings.extension.get_item_configs","text":"Get the selection and rendering configuration merged into the global configuration of the given handler. Parameters: Name Type Description Default handler_config dict The global configuration of a handler. It can be an empty dictionary. required config dict The configuration to merge into the global handler configuration. required Returns: Type Description Tuple[dict, dict] Two dictionaries: selection and rendering. The local configurations are merged into the global ones. Source code in mkdocstrings/extension.py def get_item_configs ( handler_config : dict , config : dict ) -> Tuple [ dict , dict ]: \"\"\" Get the selection and rendering configuration merged into the global configuration of the given handler. Arguments: handler_config: The global configuration of a handler. It can be an empty dictionary. config: The configuration to merge into the global handler configuration. Returns: Two dictionaries: selection and rendering. The local configurations are merged into the global ones. \"\"\" item_selection_config = dict ( handler_config . get ( \"selection\" , {})) item_selection_config . update ( config . get ( \"selection\" , {})) item_rendering_config = dict ( handler_config . get ( \"rendering\" , {})) item_rendering_config . update ( config . get ( \"rendering\" , {})) return item_selection_config , item_rendering_config","title":"get_item_configs()"},{"location":"reference/extension/#mkdocstrings.extension.log_xml_parse_error","text":"Log an XML parsing error. If the error is a tag mismatch, augment the log message. Parameters: Name Type Description Default error str The error message (no traceback). required xml_text str The XML text that generated the parsing error. required Source code in mkdocstrings/extension.py def log_xml_parse_error ( error : str , xml_text : str ) -> None : \"\"\" Log an XML parsing error. If the error is a tag mismatch, augment the log message. Arguments: error: The error message (no traceback). xml_text: The XML text that generated the parsing error. \"\"\" message = f \"mkdocstrings.extension: { error } \" if \"mismatched tag\" in error : line_column = error [ error . rfind ( \":\" ) + 1 :] line , column = line_column . split ( \", \" ) lineno = int ( line [ line . rfind ( \" \" ) + 1 :]) columnno = int ( column [ column . rfind ( \" \" ) + 1 :]) line = xml_text . split ( \" \\n \" )[ lineno - 1 ] character = line [ columnno ] message += ( f \" (character { character } ): \\n { line } \\n \" \"If your Markdown contains angle brackets < >, try to wrap them between backticks `< >`, \" \"or replace them with < and >\" ) log . error ( message )","title":"log_xml_parse_error()"},{"location":"reference/plugin/","text":"\u00a4 This module contains the mkdocs plugin. The plugin instantiates a Markdown extension ([ MkdocstringsExtension ][mkdocstrings.extension.MkdocstringsExtension]), and adds it to the list of Markdown extensions used by mkdocs during the on_config event hook . After each page is processed by the Markdown converter, this plugin stores absolute URLs of every HTML anchors it finds to later be able to fix unresolved references. It stores them during the on_page_contents event hook . Just before writing the final HTML to the disc, during the on_post_page event hook , this plugin searches for references of the form [identifier][] or [title][identifier] that were not resolved, and fixes them using the previously stored identifier-URL mapping. Once the documentation is built, the on_post_build event hook is triggered and calls the [ handlers.teardown() method][mkdocstrings.handlers.teardown]. This method is used to teardown the [handlers][mkdocstrings.handlers] that were instantiated during documentation buildup. Finally, when serving the documentation, it can add directories to watch during the on_serve event hook . RENDERING_OPTS_KEY: str \u00a4 The name of the rendering parameter in YAML configuration blocks. SELECTION_OPTS_KEY: str \u00a4 The name of the selection parameter in YAML configuration blocks. MkdocstringsPlugin \u00a4 An mkdocs plugin. This plugin defines the following event hooks: on_config on_page_contents on_post_page on_post_build on_serve Check the Developing Plugins page of mkdocs for more information about its plugin system.. config_scheme: Tuple [ Tuple [ str , mkdocs . config . config_options . Type ]] \u00a4 The configuration options of mkdocstrings , written in mkdocs.yml . Available options are: watch : A list of directories to watch. Only used when serving the documentation with mkdocs. Whenever a file changes in one of directories, the whole documentation is built again, and the browser refreshed. default_handler : The default handler to use. The value is the name of the handler module. Default is \"python\". handlers : Global configuration of handlers. You can set global configuration per handler, applied everywhere, but overridable in each \"autodoc\" instruction. Example: plugins : - mkdocstrings : handlers : python : selection : selection_opt : true rendering : rendering_opt : \"value\" setup_commands : - \"import os\" - \"import django\" - \"os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'my_djang_app.settings')\" - \"django.setup()\" rust : selection : selection_opt : 2 __init__ ( self ) special \u00a4 Initialize the object. Source code in mkdocstrings/plugin.py def __init__ ( self ) -> None : \"\"\"Initialize the object.\"\"\" super () . __init__ () self . mkdocstrings_extension : Optional [ MkdocstringsExtension ] = None self . url_map : Dict [ Any , str ] = {} map_urls ( self , base_url , anchor ) \u00a4 Recurse on every anchor to map its ID to its absolute URL. This method populates self.url_map by side-effect. Parameters: Name Type Description Default base_url str The base URL to use as a prefix for each anchor's relative URL. required anchor AnchorLink The anchor to process and to recurse on. required Source code in mkdocstrings/plugin.py def map_urls ( self , base_url : str , anchor : AnchorLink ) -> None : \"\"\" Recurse on every anchor to map its ID to its absolute URL. This method populates `self.url_map` by side-effect. Arguments: base_url: The base URL to use as a prefix for each anchor's relative URL. anchor: The anchor to process and to recurse on. \"\"\" self . url_map [ anchor . id ] = base_url + anchor . url for child in anchor . children : self . map_urls ( base_url , child ) on_config ( self , config , ** kwargs ) \u00a4 Instantiate our Markdown extension. Hook for the on_config event . In this hook, we instantiate our [ MkdocstringsExtension ][mkdocstrings.extension.MkdocstringsExtension] and add it to the list of Markdown extensions used by mkdocs . We pass this plugin's configuration dictionary to the extension when instantiating it (it will need it later when processing markdown to get handlers and their global configurations). Parameters: Name Type Description Default config Config The MkDocs config object. required kwargs Additional arguments passed by MkDocs. {} Returns: Type Description Config The modified config. Source code in mkdocstrings/plugin.py def on_config ( self , config : Config , ** kwargs ) -> Config : # noqa: W0613 (unused arguments) \"\"\" Instantiate our Markdown extension. Hook for the [`on_config` event](https://www.mkdocs.org/user-guide/plugins/#on_config). In this hook, we instantiate our [`MkdocstringsExtension`][mkdocstrings.extension.MkdocstringsExtension] and add it to the list of Markdown extensions used by `mkdocs`. We pass this plugin's configuration dictionary to the extension when instantiating it (it will need it later when processing markdown to get handlers and their global configurations). Arguments: config: The MkDocs config object. kwargs: Additional arguments passed by MkDocs. Returns: The modified config. \"\"\" log . debug ( \"mkdocstrings.plugin: Adding extension to the list\" ) theme_name = None if config [ \"theme\" ] . name is None : theme_name = os . path . dirname ( config [ \"theme\" ] . dirs [ 0 ]) else : theme_name = config [ \"theme\" ] . name extension_config = { \"theme_name\" : theme_name , \"mdx\" : config [ \"markdown_extensions\" ], \"mdx_configs\" : config [ \"mdx_configs\" ], \"mkdocstrings\" : self . config , } self . mkdocstrings_extension = MkdocstringsExtension ( config = extension_config ) config [ \"markdown_extensions\" ] . append ( self . mkdocstrings_extension ) return config on_page_content ( self , html , page , ** kwargs ) \u00a4 Map anchors to URLs. Hook for the on_page_contents event . In this hook, we map the IDs of every anchor found in the table of contents to the anchors absolute URLs. This mapping will be used later to fix unresolved reference of the form [title][identifier] or [identifier][] . Parameters: Name Type Description Default html str HTML converted from Markdown. required page Page The related MkDocs page instance. required kwargs Additional arguments passed by MkDocs. {} Returns: Type Description str The same HTML. We only use this hook to map anchors to URLs. Source code in mkdocstrings/plugin.py def on_page_content ( self , html : str , page : Page , ** kwargs ) -> str : # noqa: W0613 (unused arguments) \"\"\" Map anchors to URLs. Hook for the [`on_page_contents` event](https://www.mkdocs.org/user-guide/plugins/#on_page_contents). In this hook, we map the IDs of every anchor found in the table of contents to the anchors absolute URLs. This mapping will be used later to fix unresolved reference of the form `[title][identifier]` or `[identifier][]`. Arguments: html: HTML converted from Markdown. page: The related MkDocs page instance. kwargs: Additional arguments passed by MkDocs. Returns: The same HTML. We only use this hook to map anchors to URLs. \"\"\" log . debug ( f \"mkdocstrings.plugin: Mapping identifiers to URLs for page { page . file . src_path } \" ) for item in page . toc . items : self . map_urls ( page . url , item ) return html on_post_build ( self , ** kwargs ) \u00a4 Teardown the handlers. Hook for the on_post_build event . This hook is used to teardown all the handlers that were instantiated and cached during documentation buildup. For example, the [Python handler's collector][mkdocstrings.handlers.python.PythonCollector] opens a subprocess in the background and keeps it open to feed it the \"autodoc\" instructions and get back JSON data. Therefore, it must close it at some point, and it does it in its [ teardown() method][mkdocstrings.handlers.python.PythonCollector.teardown] which is indirectly called by this hook. Parameters: Name Type Description Default kwargs Additional arguments passed by MkDocs. {} Source code in mkdocstrings/plugin.py def on_post_build ( self , ** kwargs ) -> None : # noqa: W0613,R0201 (unused arguments, cannot be static) \"\"\" Teardown the handlers. Hook for the [`on_post_build` event](https://www.mkdocs.org/user-guide/plugins/#on_post_build). This hook is used to teardown all the handlers that were instantiated and cached during documentation buildup. For example, the [Python handler's collector][mkdocstrings.handlers.python.PythonCollector] opens a subprocess in the background and keeps it open to feed it the \"autodoc\" instructions and get back JSON data. Therefore, it must close it at some point, and it does it in its [`teardown()` method][mkdocstrings.handlers.python.PythonCollector.teardown] which is indirectly called by this hook. Arguments: kwargs: Additional arguments passed by MkDocs. \"\"\" log . debug ( \"mkdocstrings.plugin: Tearing handlers down\" ) teardown () on_post_page ( self , output , page , ** kwargs ) \u00a4 Fix cross-references. Hook for the on_post_page event . In this hook, we try to fix unresolved references of the form [title][identifier] or [identifier][] . Doing that allows the user of mkdocstrings to cross-reference objects in their documentation strings. It uses the native Markdown syntax so it's easy to remember and use. We log a warning for each reference that we couldn't map to an URL, but try to be smart and ignore identifiers that do not look legitimate (sometimes documentation can contain strings matching our [ AUTO_REF ][mkdocstrings.references.AUTO_REF] regular expression that did not intend to reference anything). We currently ignore references when their identifier contains a space or a slash. Parameters: Name Type Description Default output str HTML converted from Markdown. required page Page The related MkDocs page instance. required kwargs Additional arguments passed by MkDocs. {} Returns: Type Description str Modified HTML. Source code in mkdocstrings/plugin.py def on_post_page ( self , output : str , page : Page , ** kwargs ) -> str : # noqa: W0613 (unused arguments) \"\"\" Fix cross-references. Hook for the [`on_post_page` event](https://www.mkdocs.org/user-guide/plugins/#on_post_page). In this hook, we try to fix unresolved references of the form `[title][identifier]` or `[identifier][]`. Doing that allows the user of `mkdocstrings` to cross-reference objects in their documentation strings. It uses the native Markdown syntax so it's easy to remember and use. We log a warning for each reference that we couldn't map to an URL, but try to be smart and ignore identifiers that do not look legitimate (sometimes documentation can contain strings matching our [`AUTO_REF`][mkdocstrings.references.AUTO_REF] regular expression that did not intend to reference anything). We currently ignore references when their identifier contains a space or a slash. Arguments: output: HTML converted from Markdown. page: The related MkDocs page instance. kwargs: Additional arguments passed by MkDocs. Returns: Modified HTML. \"\"\" log . debug ( f \"mkdocstrings.plugin: Fixing references in page { page . file . src_path } \" ) fixed_output , unmapped = fix_refs ( output , page . url , self . url_map ) if unmapped and log . isEnabledFor ( logging . WARNING ): for ref in unmapped : log . warning ( f \"mkdocstrings.plugin: { page . file . src_path } : Could not find cross-reference target '[ { ref } ]'\" , ) return fixed_output on_serve ( self , server , builder = None , ** kwargs ) \u00a4 Watch directories. Hook for the on_serve event . In this hook, we add the directories specified in the plugin's configuration to the list of directories watched by mkdocs . Whenever a change occurs in one of these directories, the documentation is built again and the site reloaded. Parameters: Name Type Description Default server Server The livereload server instance. required builder Callable The function to build the site. None kwargs Additional arguments passed by MkDocs. {} Returns: Type Description Server The server instance. Source code in mkdocstrings/plugin.py def on_serve ( self , server : Server , builder : Callable = None , ** kwargs ) -> Server : # noqa: W0613 (unused arguments) \"\"\" Watch directories. Hook for the [`on_serve` event](https://www.mkdocs.org/user-guide/plugins/#on_serve). In this hook, we add the directories specified in the plugin's configuration to the list of directories watched by `mkdocs`. Whenever a change occurs in one of these directories, the documentation is built again and the site reloaded. Arguments: server: The `livereload` server instance. builder: The function to build the site. kwargs: Additional arguments passed by MkDocs. Returns: The server instance. \"\"\" if builder is None : # The builder parameter was added in mkdocs v1.1.1. # See issue https://github.com/mkdocs/mkdocs/issues/1952. builder = list ( server . watcher . _tasks . values ())[ 0 ][ \"func\" ] # noqa: WPS437 (protected attribute) for element in self . config [ \"watch\" ]: log . debug ( f \"mkdocstrings.plugin: Adding directory ' { element } ' to watcher\" ) server . watch ( element , builder ) return server","title":"plugin.py"},{"location":"reference/plugin/#mkdocstrings.plugin","text":"This module contains the mkdocs plugin. The plugin instantiates a Markdown extension ([ MkdocstringsExtension ][mkdocstrings.extension.MkdocstringsExtension]), and adds it to the list of Markdown extensions used by mkdocs during the on_config event hook . After each page is processed by the Markdown converter, this plugin stores absolute URLs of every HTML anchors it finds to later be able to fix unresolved references. It stores them during the on_page_contents event hook . Just before writing the final HTML to the disc, during the on_post_page event hook , this plugin searches for references of the form [identifier][] or [title][identifier] that were not resolved, and fixes them using the previously stored identifier-URL mapping. Once the documentation is built, the on_post_build event hook is triggered and calls the [ handlers.teardown() method][mkdocstrings.handlers.teardown]. This method is used to teardown the [handlers][mkdocstrings.handlers] that were instantiated during documentation buildup. Finally, when serving the documentation, it can add directories to watch during the on_serve event hook .","title":"mkdocstrings.plugin"},{"location":"reference/plugin/#mkdocstrings.plugin.RENDERING_OPTS_KEY","text":"The name of the rendering parameter in YAML configuration blocks.","title":"RENDERING_OPTS_KEY"},{"location":"reference/plugin/#mkdocstrings.plugin.SELECTION_OPTS_KEY","text":"The name of the selection parameter in YAML configuration blocks.","title":"SELECTION_OPTS_KEY"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin","text":"An mkdocs plugin. This plugin defines the following event hooks: on_config on_page_contents on_post_page on_post_build on_serve Check the Developing Plugins page of mkdocs for more information about its plugin system..","title":"MkdocstringsPlugin"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.config_scheme","text":"The configuration options of mkdocstrings , written in mkdocs.yml . Available options are: watch : A list of directories to watch. Only used when serving the documentation with mkdocs. Whenever a file changes in one of directories, the whole documentation is built again, and the browser refreshed. default_handler : The default handler to use. The value is the name of the handler module. Default is \"python\". handlers : Global configuration of handlers. You can set global configuration per handler, applied everywhere, but overridable in each \"autodoc\" instruction. Example: plugins : - mkdocstrings : handlers : python : selection : selection_opt : true rendering : rendering_opt : \"value\" setup_commands : - \"import os\" - \"import django\" - \"os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'my_djang_app.settings')\" - \"django.setup()\" rust : selection : selection_opt : 2","title":"config_scheme"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.__init__","text":"Initialize the object. Source code in mkdocstrings/plugin.py def __init__ ( self ) -> None : \"\"\"Initialize the object.\"\"\" super () . __init__ () self . mkdocstrings_extension : Optional [ MkdocstringsExtension ] = None self . url_map : Dict [ Any , str ] = {}","title":"__init__()"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.map_urls","text":"Recurse on every anchor to map its ID to its absolute URL. This method populates self.url_map by side-effect. Parameters: Name Type Description Default base_url str The base URL to use as a prefix for each anchor's relative URL. required anchor AnchorLink The anchor to process and to recurse on. required Source code in mkdocstrings/plugin.py def map_urls ( self , base_url : str , anchor : AnchorLink ) -> None : \"\"\" Recurse on every anchor to map its ID to its absolute URL. This method populates `self.url_map` by side-effect. Arguments: base_url: The base URL to use as a prefix for each anchor's relative URL. anchor: The anchor to process and to recurse on. \"\"\" self . url_map [ anchor . id ] = base_url + anchor . url for child in anchor . children : self . map_urls ( base_url , child )","title":"map_urls()"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.on_config","text":"Instantiate our Markdown extension. Hook for the on_config event . In this hook, we instantiate our [ MkdocstringsExtension ][mkdocstrings.extension.MkdocstringsExtension] and add it to the list of Markdown extensions used by mkdocs . We pass this plugin's configuration dictionary to the extension when instantiating it (it will need it later when processing markdown to get handlers and their global configurations). Parameters: Name Type Description Default config Config The MkDocs config object. required kwargs Additional arguments passed by MkDocs. {} Returns: Type Description Config The modified config. Source code in mkdocstrings/plugin.py def on_config ( self , config : Config , ** kwargs ) -> Config : # noqa: W0613 (unused arguments) \"\"\" Instantiate our Markdown extension. Hook for the [`on_config` event](https://www.mkdocs.org/user-guide/plugins/#on_config). In this hook, we instantiate our [`MkdocstringsExtension`][mkdocstrings.extension.MkdocstringsExtension] and add it to the list of Markdown extensions used by `mkdocs`. We pass this plugin's configuration dictionary to the extension when instantiating it (it will need it later when processing markdown to get handlers and their global configurations). Arguments: config: The MkDocs config object. kwargs: Additional arguments passed by MkDocs. Returns: The modified config. \"\"\" log . debug ( \"mkdocstrings.plugin: Adding extension to the list\" ) theme_name = None if config [ \"theme\" ] . name is None : theme_name = os . path . dirname ( config [ \"theme\" ] . dirs [ 0 ]) else : theme_name = config [ \"theme\" ] . name extension_config = { \"theme_name\" : theme_name , \"mdx\" : config [ \"markdown_extensions\" ], \"mdx_configs\" : config [ \"mdx_configs\" ], \"mkdocstrings\" : self . config , } self . mkdocstrings_extension = MkdocstringsExtension ( config = extension_config ) config [ \"markdown_extensions\" ] . append ( self . mkdocstrings_extension ) return config","title":"on_config()"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.on_page_content","text":"Map anchors to URLs. Hook for the on_page_contents event . In this hook, we map the IDs of every anchor found in the table of contents to the anchors absolute URLs. This mapping will be used later to fix unresolved reference of the form [title][identifier] or [identifier][] . Parameters: Name Type Description Default html str HTML converted from Markdown. required page Page The related MkDocs page instance. required kwargs Additional arguments passed by MkDocs. {} Returns: Type Description str The same HTML. We only use this hook to map anchors to URLs. Source code in mkdocstrings/plugin.py def on_page_content ( self , html : str , page : Page , ** kwargs ) -> str : # noqa: W0613 (unused arguments) \"\"\" Map anchors to URLs. Hook for the [`on_page_contents` event](https://www.mkdocs.org/user-guide/plugins/#on_page_contents). In this hook, we map the IDs of every anchor found in the table of contents to the anchors absolute URLs. This mapping will be used later to fix unresolved reference of the form `[title][identifier]` or `[identifier][]`. Arguments: html: HTML converted from Markdown. page: The related MkDocs page instance. kwargs: Additional arguments passed by MkDocs. Returns: The same HTML. We only use this hook to map anchors to URLs. \"\"\" log . debug ( f \"mkdocstrings.plugin: Mapping identifiers to URLs for page { page . file . src_path } \" ) for item in page . toc . items : self . map_urls ( page . url , item ) return html","title":"on_page_content()"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.on_post_build","text":"Teardown the handlers. Hook for the on_post_build event . This hook is used to teardown all the handlers that were instantiated and cached during documentation buildup. For example, the [Python handler's collector][mkdocstrings.handlers.python.PythonCollector] opens a subprocess in the background and keeps it open to feed it the \"autodoc\" instructions and get back JSON data. Therefore, it must close it at some point, and it does it in its [ teardown() method][mkdocstrings.handlers.python.PythonCollector.teardown] which is indirectly called by this hook. Parameters: Name Type Description Default kwargs Additional arguments passed by MkDocs. {} Source code in mkdocstrings/plugin.py def on_post_build ( self , ** kwargs ) -> None : # noqa: W0613,R0201 (unused arguments, cannot be static) \"\"\" Teardown the handlers. Hook for the [`on_post_build` event](https://www.mkdocs.org/user-guide/plugins/#on_post_build). This hook is used to teardown all the handlers that were instantiated and cached during documentation buildup. For example, the [Python handler's collector][mkdocstrings.handlers.python.PythonCollector] opens a subprocess in the background and keeps it open to feed it the \"autodoc\" instructions and get back JSON data. Therefore, it must close it at some point, and it does it in its [`teardown()` method][mkdocstrings.handlers.python.PythonCollector.teardown] which is indirectly called by this hook. Arguments: kwargs: Additional arguments passed by MkDocs. \"\"\" log . debug ( \"mkdocstrings.plugin: Tearing handlers down\" ) teardown ()","title":"on_post_build()"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.on_post_page","text":"Fix cross-references. Hook for the on_post_page event . In this hook, we try to fix unresolved references of the form [title][identifier] or [identifier][] . Doing that allows the user of mkdocstrings to cross-reference objects in their documentation strings. It uses the native Markdown syntax so it's easy to remember and use. We log a warning for each reference that we couldn't map to an URL, but try to be smart and ignore identifiers that do not look legitimate (sometimes documentation can contain strings matching our [ AUTO_REF ][mkdocstrings.references.AUTO_REF] regular expression that did not intend to reference anything). We currently ignore references when their identifier contains a space or a slash. Parameters: Name Type Description Default output str HTML converted from Markdown. required page Page The related MkDocs page instance. required kwargs Additional arguments passed by MkDocs. {} Returns: Type Description str Modified HTML. Source code in mkdocstrings/plugin.py def on_post_page ( self , output : str , page : Page , ** kwargs ) -> str : # noqa: W0613 (unused arguments) \"\"\" Fix cross-references. Hook for the [`on_post_page` event](https://www.mkdocs.org/user-guide/plugins/#on_post_page). In this hook, we try to fix unresolved references of the form `[title][identifier]` or `[identifier][]`. Doing that allows the user of `mkdocstrings` to cross-reference objects in their documentation strings. It uses the native Markdown syntax so it's easy to remember and use. We log a warning for each reference that we couldn't map to an URL, but try to be smart and ignore identifiers that do not look legitimate (sometimes documentation can contain strings matching our [`AUTO_REF`][mkdocstrings.references.AUTO_REF] regular expression that did not intend to reference anything). We currently ignore references when their identifier contains a space or a slash. Arguments: output: HTML converted from Markdown. page: The related MkDocs page instance. kwargs: Additional arguments passed by MkDocs. Returns: Modified HTML. \"\"\" log . debug ( f \"mkdocstrings.plugin: Fixing references in page { page . file . src_path } \" ) fixed_output , unmapped = fix_refs ( output , page . url , self . url_map ) if unmapped and log . isEnabledFor ( logging . WARNING ): for ref in unmapped : log . warning ( f \"mkdocstrings.plugin: { page . file . src_path } : Could not find cross-reference target '[ { ref } ]'\" , ) return fixed_output","title":"on_post_page()"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.on_serve","text":"Watch directories. Hook for the on_serve event . In this hook, we add the directories specified in the plugin's configuration to the list of directories watched by mkdocs . Whenever a change occurs in one of these directories, the documentation is built again and the site reloaded. Parameters: Name Type Description Default server Server The livereload server instance. required builder Callable The function to build the site. None kwargs Additional arguments passed by MkDocs. {} Returns: Type Description Server The server instance. Source code in mkdocstrings/plugin.py def on_serve ( self , server : Server , builder : Callable = None , ** kwargs ) -> Server : # noqa: W0613 (unused arguments) \"\"\" Watch directories. Hook for the [`on_serve` event](https://www.mkdocs.org/user-guide/plugins/#on_serve). In this hook, we add the directories specified in the plugin's configuration to the list of directories watched by `mkdocs`. Whenever a change occurs in one of these directories, the documentation is built again and the site reloaded. Arguments: server: The `livereload` server instance. builder: The function to build the site. kwargs: Additional arguments passed by MkDocs. Returns: The server instance. \"\"\" if builder is None : # The builder parameter was added in mkdocs v1.1.1. # See issue https://github.com/mkdocs/mkdocs/issues/1952. builder = list ( server . watcher . _tasks . values ())[ 0 ][ \"func\" ] # noqa: WPS437 (protected attribute) for element in self . config [ \"watch\" ]: log . debug ( f \"mkdocstrings.plugin: Adding directory ' { element } ' to watcher\" ) server . watch ( element , builder ) return server","title":"on_serve()"},{"location":"reference/references/","text":"\u00a4 Cross-references module. AUTO_REF: Pattern \u00a4 A regular expression to match unresolved Markdown references in the [ on_post_page hook][mkdocstrings.plugin.MkdocstringsPlugin.on_post_page]. Placeholder \u00a4 This class is used as a placeholder store. Placeholders are random, unique strings that temporarily replace <code> nodes in an HTML tree. Why do we replace these nodes with such strings? Because we want to fix cross-references that were not resolved during Markdown conversion, and we must never touch to what's inside of a code block. To ease the process, instead of selecting nodes in the HTML tree with complex filters (I tried, believe me), we simply \"hide\" the code nodes, and bulk-replace unresolved cross-references in the whole HTML text at once, with a regular expression substitution. Once it's done, we bulk-replace code nodes back, with a regular expression substitution again. __init__ ( self , seed_length = 16 ) special \u00a4 Initialize the object. Parameters: Name Type Description Default seed_length Length of the seed. 16 Source code in mkdocstrings/references.py def __init__ ( self , seed_length = 16 ) -> None : \"\"\" Initialize the object. Arguments: seed_length: Length of the seed. \"\"\" self . _store : List [ str ] = [] self . seed = \"\" self . seed_length = seed_length self . set_seed () replace_code_tags ( self , soup ) \u00a4 Recursively replace code nodes with navigable strings whose values are unique IDs. Parameters: Name Type Description Default soup BeautifulSoup The root tag of a BeautifulSoup HTML tree. required Source code in mkdocstrings/references.py def replace_code_tags ( self , soup : BeautifulSoup ) -> None : \"\"\" Recursively replace code nodes with navigable strings whose values are unique IDs. Arguments: soup: The root tag of a BeautifulSoup HTML tree. \"\"\" self . _recursive_replace ( soup ) restore_code_tags ( self , soup_str ) \u00a4 Restore code nodes previously replaced by unique placeholders. Parameters: Name Type Description Default soup_str str HTML text. required Returns: Type Description str The same HTML text with placeholders replaced by their respective original code nodes. Source code in mkdocstrings/references.py def restore_code_tags ( self , soup_str : str ) -> str : \"\"\" Restore code nodes previously replaced by unique placeholders. Arguments: soup_str: HTML text. Returns: The same HTML text with placeholders replaced by their respective original code nodes. \"\"\" return re . sub ( rf \" { self . seed } (\\d+)\" , self . _replace_id_with_value , soup_str ) set_seed ( self ) \u00a4 Reset the seed in self.seed with a random string. Source code in mkdocstrings/references.py def set_seed ( self ) -> None : \"\"\"Reset the seed in `self.seed` with a random string.\"\"\" alphabet = string . ascii_letters + string . digits self . seed = \"\" . join ( random . choices ( alphabet , k = self . seed_length )) store ( self , value ) \u00a4 Store a text under a unique ID, return that ID. Parameters: Name Type Description Default value str The text to store. required Returns: Type Description str The ID under which the text is stored. Source code in mkdocstrings/references.py def store ( self , value : str ) -> str : \"\"\" Store a text under a unique ID, return that ID. Arguments: value: The text to store. Returns: The ID under which the text is stored. \"\"\" new_id = f \" { self . seed }{ len ( self . _store ) } \" self . _store . append ( value ) return new_id fix_ref ( url_map , from_url , unmapped ) \u00a4 Return a repl function for re.sub . In our context, we match Markdown references and replace them with HTML links. When the matched reference's identifier contains a space or slash, we do nothing as we consider it to be unintended. When the matched reference's identifier was not mapped to an URL, we append the identifier to the outer unmapped list. It generally means the user is trying to cross-reference an object that was not collected and rendered, making it impossible to link to it. We catch this exception in the caller to issue a warning. Parameters: Name Type Description Default url_map The mapping of objects and their URLs. required from_url The URL of the base page, from which we link towards the targeted pages. required unmapped List[str] A list to store unmapped identifiers. required Returns: Type Description Callable The actual function accepting a Match object and returning the replacement strings. Source code in mkdocstrings/references.py def fix_ref ( url_map , from_url , unmapped : List [ str ]) -> Callable : # noqa: WPS231 (not that complex) \"\"\" Return a `repl` function for [`re.sub`](https://docs.python.org/3/library/re.html#re.sub). In our context, we match Markdown references and replace them with HTML links. When the matched reference's identifier contains a space or slash, we do nothing as we consider it to be unintended. When the matched reference's identifier was not mapped to an URL, we append the identifier to the outer `unmapped` list. It generally means the user is trying to cross-reference an object that was not collected and rendered, making it impossible to link to it. We catch this exception in the caller to issue a warning. Arguments: url_map: The mapping of objects and their URLs. from_url: The URL of the base page, from which we link towards the targeted pages. unmapped: A list to store unmapped identifiers. Returns: The actual function accepting a [`Match` object](https://docs.python.org/3/library/re.html#match-objects) and returning the replacement strings. \"\"\" def inner ( match : Match ): # noqa: WPS430 (nested function, no other way than side-effecting the warnings) groups = match . groupdict () identifier = groups [ \"identifier\" ] title = groups [ \"title\" ] if title and not identifier : identifier , title = title , identifier try : url = relative_url ( from_url , url_map [ identifier ]) except KeyError : if \" \" not in identifier and \"/\" not in identifier : unmapped . append ( identifier ) if not title : return f \"[ { identifier } ][]\" return f \"[ { title } ][ { identifier } ]\" return f '<a href=\" { url } \"> { title or identifier } </a>' return inner fix_refs ( html , from_url , url_map ) \u00a4 Fix all references in the given HTML text. Parameters: Name Type Description Default html str The text to fix. required from_url str The URL at which this HTML is served. required url_map Dict[str, str] The mapping of objects and their URLs. required Returns: Type Description Tuple[str, List[str]] The fixed HTML. Source code in mkdocstrings/references.py def fix_refs ( html : str , from_url : str , url_map : Dict [ str , str ], ) -> Tuple [ str , List [ str ]]: \"\"\" Fix all references in the given HTML text. Arguments: html: The text to fix. from_url: The URL at which this HTML is served. url_map: The mapping of objects and their URLs. Returns: The fixed HTML. \"\"\" unmapped = [] # type: ignore if not AUTO_REF . search ( html ): return html , unmapped urls = \" \\n \" . join ( set ( url_map . values ())) placeholder = Placeholder () while re . search ( placeholder . seed , html ) or placeholder . seed in urls : placeholder . set_seed () soup = BeautifulSoup ( html , \"html.parser\" ) placeholder . replace_code_tags ( soup ) fixed_soup = AUTO_REF . sub ( fix_ref ( url_map , from_url , unmapped ), str ( soup )) return placeholder . restore_code_tags ( fixed_soup ), unmapped relative_url ( url_a , url_b ) \u00a4 Compute the relative path from URL A to URL B. Parameters: Name Type Description Default url_a str URL A. required url_b str URL B. required Returns: Type Description str The relative URL to go from A to B. Source code in mkdocstrings/references.py def relative_url ( url_a : str , url_b : str ) -> str : \"\"\" Compute the relative path from URL A to URL B. Arguments: url_a: URL A. url_b: URL B. Returns: The relative URL to go from A to B. \"\"\" directory_url = False if url_a [ - 1 ] == \"/\" : url_a = url_a . rstrip ( \"/\" ) directory_url = True parts_a = url_a . split ( \"/\" ) url_b , anchor = url_b . split ( \"#\" , 1 ) parts_b = url_b . split ( \"/\" ) # remove common left parts while parts_a and parts_b and parts_a [ 0 ] == parts_b [ 0 ]: parts_a . pop ( 0 ) parts_b . pop ( 0 ) # go up as many times as remaining a parts' depth levels = len ( parts_a ) if not directory_url : levels -= 1 parts_relative = [ \"..\" ] * levels + parts_b # noqa: WPS435 (list multiply ok) relative = \"/\" . join ( parts_relative ) return f \" { relative } # { anchor } \"","title":"references.py"},{"location":"reference/references/#mkdocstrings.references","text":"Cross-references module.","title":"mkdocstrings.references"},{"location":"reference/references/#mkdocstrings.references.AUTO_REF","text":"A regular expression to match unresolved Markdown references in the [ on_post_page hook][mkdocstrings.plugin.MkdocstringsPlugin.on_post_page].","title":"AUTO_REF"},{"location":"reference/references/#mkdocstrings.references.Placeholder","text":"This class is used as a placeholder store. Placeholders are random, unique strings that temporarily replace <code> nodes in an HTML tree. Why do we replace these nodes with such strings? Because we want to fix cross-references that were not resolved during Markdown conversion, and we must never touch to what's inside of a code block. To ease the process, instead of selecting nodes in the HTML tree with complex filters (I tried, believe me), we simply \"hide\" the code nodes, and bulk-replace unresolved cross-references in the whole HTML text at once, with a regular expression substitution. Once it's done, we bulk-replace code nodes back, with a regular expression substitution again.","title":"Placeholder"},{"location":"reference/references/#mkdocstrings.references.Placeholder.__init__","text":"Initialize the object. Parameters: Name Type Description Default seed_length Length of the seed. 16 Source code in mkdocstrings/references.py def __init__ ( self , seed_length = 16 ) -> None : \"\"\" Initialize the object. Arguments: seed_length: Length of the seed. \"\"\" self . _store : List [ str ] = [] self . seed = \"\" self . seed_length = seed_length self . set_seed ()","title":"__init__()"},{"location":"reference/references/#mkdocstrings.references.Placeholder.replace_code_tags","text":"Recursively replace code nodes with navigable strings whose values are unique IDs. Parameters: Name Type Description Default soup BeautifulSoup The root tag of a BeautifulSoup HTML tree. required Source code in mkdocstrings/references.py def replace_code_tags ( self , soup : BeautifulSoup ) -> None : \"\"\" Recursively replace code nodes with navigable strings whose values are unique IDs. Arguments: soup: The root tag of a BeautifulSoup HTML tree. \"\"\" self . _recursive_replace ( soup )","title":"replace_code_tags()"},{"location":"reference/references/#mkdocstrings.references.Placeholder.restore_code_tags","text":"Restore code nodes previously replaced by unique placeholders. Parameters: Name Type Description Default soup_str str HTML text. required Returns: Type Description str The same HTML text with placeholders replaced by their respective original code nodes. Source code in mkdocstrings/references.py def restore_code_tags ( self , soup_str : str ) -> str : \"\"\" Restore code nodes previously replaced by unique placeholders. Arguments: soup_str: HTML text. Returns: The same HTML text with placeholders replaced by their respective original code nodes. \"\"\" return re . sub ( rf \" { self . seed } (\\d+)\" , self . _replace_id_with_value , soup_str )","title":"restore_code_tags()"},{"location":"reference/references/#mkdocstrings.references.Placeholder.set_seed","text":"Reset the seed in self.seed with a random string. Source code in mkdocstrings/references.py def set_seed ( self ) -> None : \"\"\"Reset the seed in `self.seed` with a random string.\"\"\" alphabet = string . ascii_letters + string . digits self . seed = \"\" . join ( random . choices ( alphabet , k = self . seed_length ))","title":"set_seed()"},{"location":"reference/references/#mkdocstrings.references.Placeholder.store","text":"Store a text under a unique ID, return that ID. Parameters: Name Type Description Default value str The text to store. required Returns: Type Description str The ID under which the text is stored. Source code in mkdocstrings/references.py def store ( self , value : str ) -> str : \"\"\" Store a text under a unique ID, return that ID. Arguments: value: The text to store. Returns: The ID under which the text is stored. \"\"\" new_id = f \" { self . seed }{ len ( self . _store ) } \" self . _store . append ( value ) return new_id","title":"store()"},{"location":"reference/references/#mkdocstrings.references.fix_ref","text":"Return a repl function for re.sub . In our context, we match Markdown references and replace them with HTML links. When the matched reference's identifier contains a space or slash, we do nothing as we consider it to be unintended. When the matched reference's identifier was not mapped to an URL, we append the identifier to the outer unmapped list. It generally means the user is trying to cross-reference an object that was not collected and rendered, making it impossible to link to it. We catch this exception in the caller to issue a warning. Parameters: Name Type Description Default url_map The mapping of objects and their URLs. required from_url The URL of the base page, from which we link towards the targeted pages. required unmapped List[str] A list to store unmapped identifiers. required Returns: Type Description Callable The actual function accepting a Match object and returning the replacement strings. Source code in mkdocstrings/references.py def fix_ref ( url_map , from_url , unmapped : List [ str ]) -> Callable : # noqa: WPS231 (not that complex) \"\"\" Return a `repl` function for [`re.sub`](https://docs.python.org/3/library/re.html#re.sub). In our context, we match Markdown references and replace them with HTML links. When the matched reference's identifier contains a space or slash, we do nothing as we consider it to be unintended. When the matched reference's identifier was not mapped to an URL, we append the identifier to the outer `unmapped` list. It generally means the user is trying to cross-reference an object that was not collected and rendered, making it impossible to link to it. We catch this exception in the caller to issue a warning. Arguments: url_map: The mapping of objects and their URLs. from_url: The URL of the base page, from which we link towards the targeted pages. unmapped: A list to store unmapped identifiers. Returns: The actual function accepting a [`Match` object](https://docs.python.org/3/library/re.html#match-objects) and returning the replacement strings. \"\"\" def inner ( match : Match ): # noqa: WPS430 (nested function, no other way than side-effecting the warnings) groups = match . groupdict () identifier = groups [ \"identifier\" ] title = groups [ \"title\" ] if title and not identifier : identifier , title = title , identifier try : url = relative_url ( from_url , url_map [ identifier ]) except KeyError : if \" \" not in identifier and \"/\" not in identifier : unmapped . append ( identifier ) if not title : return f \"[ { identifier } ][]\" return f \"[ { title } ][ { identifier } ]\" return f '<a href=\" { url } \"> { title or identifier } </a>' return inner","title":"fix_ref()"},{"location":"reference/references/#mkdocstrings.references.fix_refs","text":"Fix all references in the given HTML text. Parameters: Name Type Description Default html str The text to fix. required from_url str The URL at which this HTML is served. required url_map Dict[str, str] The mapping of objects and their URLs. required Returns: Type Description Tuple[str, List[str]] The fixed HTML. Source code in mkdocstrings/references.py def fix_refs ( html : str , from_url : str , url_map : Dict [ str , str ], ) -> Tuple [ str , List [ str ]]: \"\"\" Fix all references in the given HTML text. Arguments: html: The text to fix. from_url: The URL at which this HTML is served. url_map: The mapping of objects and their URLs. Returns: The fixed HTML. \"\"\" unmapped = [] # type: ignore if not AUTO_REF . search ( html ): return html , unmapped urls = \" \\n \" . join ( set ( url_map . values ())) placeholder = Placeholder () while re . search ( placeholder . seed , html ) or placeholder . seed in urls : placeholder . set_seed () soup = BeautifulSoup ( html , \"html.parser\" ) placeholder . replace_code_tags ( soup ) fixed_soup = AUTO_REF . sub ( fix_ref ( url_map , from_url , unmapped ), str ( soup )) return placeholder . restore_code_tags ( fixed_soup ), unmapped","title":"fix_refs()"},{"location":"reference/references/#mkdocstrings.references.relative_url","text":"Compute the relative path from URL A to URL B. Parameters: Name Type Description Default url_a str URL A. required url_b str URL B. required Returns: Type Description str The relative URL to go from A to B. Source code in mkdocstrings/references.py def relative_url ( url_a : str , url_b : str ) -> str : \"\"\" Compute the relative path from URL A to URL B. Arguments: url_a: URL A. url_b: URL B. Returns: The relative URL to go from A to B. \"\"\" directory_url = False if url_a [ - 1 ] == \"/\" : url_a = url_a . rstrip ( \"/\" ) directory_url = True parts_a = url_a . split ( \"/\" ) url_b , anchor = url_b . split ( \"#\" , 1 ) parts_b = url_b . split ( \"/\" ) # remove common left parts while parts_a and parts_b and parts_a [ 0 ] == parts_b [ 0 ]: parts_a . pop ( 0 ) parts_b . pop ( 0 ) # go up as many times as remaining a parts' depth levels = len ( parts_a ) if not directory_url : levels -= 1 parts_relative = [ \"..\" ] * levels + parts_b # noqa: WPS435 (list multiply ok) relative = \"/\" . join ( parts_relative ) return f \" { relative } # { anchor } \"","title":"relative_url()"},{"location":"reference/handlers/__init__/","text":"\u00a4 Base module for handlers. This module contains the base classes for implementing collectors, renderers, and the combination of the two: handlers. It also provides two methods: get_handler , that will cache handlers into the HANDLERS_CACHE dictionary. teardown , that will teardown all the cached handlers, and then clear the cache. BaseCollector \u00a4 The base collector class. Inherit from this class to implement a collector. You will have to implement the collect method. You can also implement the teardown method. collect ( self , identifier , config ) \u00a4 Collect data given an identifier and selection configuration. In the implementation, you typically call a subprocess that returns JSON, and load that JSON again into a Python dictionary for example, though the implementation is completely free. Parameters: Name Type Description Default identifier str An identifier for which to collect data. For example, in Python, it would be 'mkdocstrings.handlers' to collect documentation about the handlers module. It can be anything that you can feed to the tool of your choice. required config dict Configuration options for the tool you use to collect data. Typically called \"selection\" because these options modify how the objects or documentation are \"selected\" in the source code. required Returns: Type Description Any Anything you want, as long as you can feed it to the renderer's render method. Source code in mkdocstrings/handlers/__init__.py @abstractmethod def collect ( self , identifier : str , config : dict ) -> Any : \"\"\" Collect data given an identifier and selection configuration. In the implementation, you typically call a subprocess that returns JSON, and load that JSON again into a Python dictionary for example, though the implementation is completely free. Arguments: identifier: An identifier for which to collect data. For example, in Python, it would be 'mkdocstrings.handlers' to collect documentation about the handlers module. It can be anything that you can feed to the tool of your choice. config: Configuration options for the tool you use to collect data. Typically called \"selection\" because these options modify how the objects or documentation are \"selected\" in the source code. Returns: Anything you want, as long as you can feed it to the renderer's `render` method. \"\"\" # noqa: DAR202 (excess return section) teardown ( self ) \u00a4 Teardown the collector. This method should be implemented to, for example, terminate a subprocess that was started when creating the collector instance. Source code in mkdocstrings/handlers/__init__.py def teardown ( self ) -> None : \"\"\" Teardown the collector. This method should be implemented to, for example, terminate a subprocess that was started when creating the collector instance. \"\"\" BaseHandler \u00a4 The base handler class. Inherit from this class to implement a handler. It's usually just a combination of a collector and a renderer, but you can make it as complex as you need. __init__ ( self , collector , renderer ) special \u00a4 Initialize the object. Parameters: Name Type Description Default collector BaseCollector A collector instance. required renderer BaseRenderer A renderer instance. required Source code in mkdocstrings/handlers/__init__.py def __init__ ( self , collector : BaseCollector , renderer : BaseRenderer ) -> None : \"\"\" Initialize the object. Arguments: collector: A collector instance. renderer: A renderer instance. \"\"\" self . collector = collector self . renderer = renderer BaseRenderer \u00a4 The base renderer class. Inherit from this class to implement a renderer. You will have to implement the render method. You can also override the update_env method, to add more filters to the Jinja environment, making them available in your Jinja templates. To define a fallback theme, add a FALLBACK_THEME class-variable. __init__ ( self , directory , theme , custom_templates = None ) special \u00a4 Initialize the object. If the given theme is not supported (it does not exist), it will look for a fallback_theme attribute in self to use as a fallback theme. Parameters: Name Type Description Default directory str The name of the directory containing the themes for this renderer. required theme str The name of theme to use. required custom_templates Optional[str] Directory containing custom templates. None Source code in mkdocstrings/handlers/__init__.py def __init__ ( self , directory : str , theme : str , custom_templates : Optional [ str ] = None ) -> None : \"\"\" Initialize the object. If the given theme is not supported (it does not exist), it will look for a `fallback_theme` attribute in `self` to use as a fallback theme. Arguments: directory: The name of the directory containing the themes for this renderer. theme: The name of theme to use. custom_templates: Directory containing custom templates. \"\"\" paths = [] if custom_templates is not None : paths . append ( Path ( custom_templates ) / directory / theme ) themes_dir = Path ( __file__ ) . parent . parent / \"templates\" / directory paths . append ( themes_dir / theme ) if self . fallback_theme != \"\" : paths . append ( themes_dir / self . fallback_theme ) self . env = Environment ( autoescape = True , loader = FileSystemLoader ( paths )) # type: ignore self . env . filters [ \"highlight\" ] = do_highlight self . env . filters [ \"any\" ] = do_any render ( self , data , config ) \u00a4 Render a template using provided data and configuration options. Parameters: Name Type Description Default data Any The collected data to render. required config dict The rendering options. required Returns: Type Description str The rendered template as HTML. Source code in mkdocstrings/handlers/__init__.py @abstractmethod def render ( self , data : Any , config : dict ) -> str : \"\"\" Render a template using provided data and configuration options. Arguments: data: The collected data to render. config: The rendering options. Returns: The rendered template as HTML. \"\"\" # noqa: DAR202 (excess return section) update_env ( self , md , config ) \u00a4 Update the Jinja environment. Parameters: Name Type Description Default md Markdown The Markdown instance. Useful to add functions able to convert Markdown into the environment filters. required config dict Configuration options for mkdocs and mkdocstrings , read from mkdocs.yml . See the source code of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary. required Source code in mkdocstrings/handlers/__init__.py def update_env ( self , md : Markdown , config : dict ) -> None : \"\"\" Update the Jinja environment. Arguments: md: The Markdown instance. Useful to add functions able to convert Markdown into the environment filters. config: Configuration options for `mkdocs` and `mkdocstrings`, read from `mkdocs.yml`. See the source code of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary. \"\"\" # Re-instantiate md: see https://github.com/tomchristie/mkautodoc/issues/14 md = Markdown ( extensions = config [ \"mdx\" ], extensions_configs = config [ \"mdx_configs\" ]) self . env . filters [ \"convert_markdown\" ] = lambda text : do_mark_safe ( md . convert ( text )) CollectionError \u00a4 An exception raised when some collection of data failed. ThemeNotSupported \u00a4 An exception raised to tell a theme is not supported. do_any ( seq , attribute = None ) \u00a4 Check if at least one of the item in the sequence evaluates to true. The any builtin as a filter for Jinja templates. Parameters: Name Type Description Default seq Sequence An iterable object. required attribute str The attribute name to use on each object of the iterable. None Returns: Type Description bool A boolean telling if any object of the iterable evaluated to True. Source code in mkdocstrings/handlers/__init__.py def do_any ( seq : Sequence , attribute : str = None ) -> bool : \"\"\" Check if at least one of the item in the sequence evaluates to true. The `any` builtin as a filter for Jinja templates. Arguments: seq: An iterable object. attribute: The attribute name to use on each object of the iterable. Returns: A boolean telling if any object of the iterable evaluated to True. \"\"\" if attribute is None : return any ( seq ) return any ( _ [ attribute ] for _ in seq ) do_highlight ( src , guess_lang = False , language = None , inline = False , dedent = True , line_nums = False , line_start = 1 ) \u00a4 Highlight a code-snippet. This function is used as a filter in Jinja templates. Parameters: Name Type Description Default src str The code to highlight. required guess_lang bool Whether to guess the language or not. False language str Explicitly tell what language to use for highlighting. None inline bool Whether to do inline highlighting. False dedent bool Whether to dedent the code before highlighting it or not. True line_nums bool Whether to add line numbers in the result. False line_start int The line number to start with. 1 Returns: Type Description str The highlighted code as HTML text, marked safe (not escaped for HTML). Source code in mkdocstrings/handlers/__init__.py def do_highlight ( src : str , guess_lang : bool = False , language : str = None , inline : bool = False , dedent : bool = True , line_nums : bool = False , line_start : int = 1 , ) -> str : \"\"\" Highlight a code-snippet. This function is used as a filter in Jinja templates. Arguments: src: The code to highlight. guess_lang: Whether to guess the language or not. language: Explicitly tell what language to use for highlighting. inline: Whether to do inline highlighting. dedent: Whether to dedent the code before highlighting it or not. line_nums: Whether to add line numbers in the result. line_start: The line number to start with. Returns: The highlighted code as HTML text, marked safe (not escaped for HTML). \"\"\" if dedent : src = textwrap . dedent ( src ) highlighter = Highlight ( use_pygments = True , guess_lang = guess_lang , linenums = line_nums ) result = highlighter . highlight ( src = src , language = language , linestart = line_start , inline = inline ) if inline : return do_mark_safe ( result . text ) return do_mark_safe ( result ) get_handler ( name , theme , custom_templates = None , ** config ) \u00a4 Get a handler thanks to its name. This function dynamically imports a module named \"mkdocstrings.handlers.NAME\", calls its get_handler method to get an instance of a handler, and caches it in dictionary. It means that during one run (for each reload when serving, or once when building), a handler is instantiated only once, and reused for each \"autodoc\" instruction asking for it. Parameters: Name Type Description Default name str The name of the handler. Really, it's the name of the Python module holding it. required theme str The name of the theme to use. required custom_templates Optional[str] Directory containing custom templates. None config Any Configuration passed to the handler. {} Returns: Type Description BaseHandler An instance of a subclass of [ BaseHandler ][mkdocstrings.handlers.BaseHandler], as instantiated by the get_handler method of the handler's module. Source code in mkdocstrings/handlers/__init__.py def get_handler ( name : str , theme : str , custom_templates : Optional [ str ] = None , ** config : Any , ) -> BaseHandler : \"\"\" Get a handler thanks to its name. This function dynamically imports a module named \"mkdocstrings.handlers.NAME\", calls its `get_handler` method to get an instance of a handler, and caches it in dictionary. It means that during one run (for each reload when serving, or once when building), a handler is instantiated only once, and reused for each \"autodoc\" instruction asking for it. Arguments: name: The name of the handler. Really, it's the name of the Python module holding it. theme: The name of the theme to use. custom_templates: Directory containing custom templates. config: Configuration passed to the handler. Returns: An instance of a subclass of [`BaseHandler`][mkdocstrings.handlers.BaseHandler], as instantiated by the `get_handler` method of the handler's module. \"\"\" if name not in handlers_cache : module = importlib . import_module ( f \"mkdocstrings.handlers. { name } \" ) handlers_cache [ name ] = module . get_handler ( theme , custom_templates , ** config ) # type: ignore return handlers_cache [ name ] teardown () \u00a4 Teardown all cached handlers and clear the cache. Source code in mkdocstrings/handlers/__init__.py def teardown () -> None : \"\"\"Teardown all cached handlers and clear the cache.\"\"\" for handler in handlers_cache . values (): handler . collector . teardown () handlers_cache . clear ()","title":"__init__.py"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers","text":"Base module for handlers. This module contains the base classes for implementing collectors, renderers, and the combination of the two: handlers. It also provides two methods: get_handler , that will cache handlers into the HANDLERS_CACHE dictionary. teardown , that will teardown all the cached handlers, and then clear the cache.","title":"mkdocstrings.handlers"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.BaseCollector","text":"The base collector class. Inherit from this class to implement a collector. You will have to implement the collect method. You can also implement the teardown method.","title":"BaseCollector"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.BaseCollector.collect","text":"Collect data given an identifier and selection configuration. In the implementation, you typically call a subprocess that returns JSON, and load that JSON again into a Python dictionary for example, though the implementation is completely free. Parameters: Name Type Description Default identifier str An identifier for which to collect data. For example, in Python, it would be 'mkdocstrings.handlers' to collect documentation about the handlers module. It can be anything that you can feed to the tool of your choice. required config dict Configuration options for the tool you use to collect data. Typically called \"selection\" because these options modify how the objects or documentation are \"selected\" in the source code. required Returns: Type Description Any Anything you want, as long as you can feed it to the renderer's render method. Source code in mkdocstrings/handlers/__init__.py @abstractmethod def collect ( self , identifier : str , config : dict ) -> Any : \"\"\" Collect data given an identifier and selection configuration. In the implementation, you typically call a subprocess that returns JSON, and load that JSON again into a Python dictionary for example, though the implementation is completely free. Arguments: identifier: An identifier for which to collect data. For example, in Python, it would be 'mkdocstrings.handlers' to collect documentation about the handlers module. It can be anything that you can feed to the tool of your choice. config: Configuration options for the tool you use to collect data. Typically called \"selection\" because these options modify how the objects or documentation are \"selected\" in the source code. Returns: Anything you want, as long as you can feed it to the renderer's `render` method. \"\"\" # noqa: DAR202 (excess return section)","title":"collect()"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.BaseCollector.teardown","text":"Teardown the collector. This method should be implemented to, for example, terminate a subprocess that was started when creating the collector instance. Source code in mkdocstrings/handlers/__init__.py def teardown ( self ) -> None : \"\"\" Teardown the collector. This method should be implemented to, for example, terminate a subprocess that was started when creating the collector instance. \"\"\"","title":"teardown()"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.BaseHandler","text":"The base handler class. Inherit from this class to implement a handler. It's usually just a combination of a collector and a renderer, but you can make it as complex as you need.","title":"BaseHandler"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.BaseHandler.__init__","text":"Initialize the object. Parameters: Name Type Description Default collector BaseCollector A collector instance. required renderer BaseRenderer A renderer instance. required Source code in mkdocstrings/handlers/__init__.py def __init__ ( self , collector : BaseCollector , renderer : BaseRenderer ) -> None : \"\"\" Initialize the object. Arguments: collector: A collector instance. renderer: A renderer instance. \"\"\" self . collector = collector self . renderer = renderer","title":"__init__()"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.BaseRenderer","text":"The base renderer class. Inherit from this class to implement a renderer. You will have to implement the render method. You can also override the update_env method, to add more filters to the Jinja environment, making them available in your Jinja templates. To define a fallback theme, add a FALLBACK_THEME class-variable.","title":"BaseRenderer"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.BaseRenderer.__init__","text":"Initialize the object. If the given theme is not supported (it does not exist), it will look for a fallback_theme attribute in self to use as a fallback theme. Parameters: Name Type Description Default directory str The name of the directory containing the themes for this renderer. required theme str The name of theme to use. required custom_templates Optional[str] Directory containing custom templates. None Source code in mkdocstrings/handlers/__init__.py def __init__ ( self , directory : str , theme : str , custom_templates : Optional [ str ] = None ) -> None : \"\"\" Initialize the object. If the given theme is not supported (it does not exist), it will look for a `fallback_theme` attribute in `self` to use as a fallback theme. Arguments: directory: The name of the directory containing the themes for this renderer. theme: The name of theme to use. custom_templates: Directory containing custom templates. \"\"\" paths = [] if custom_templates is not None : paths . append ( Path ( custom_templates ) / directory / theme ) themes_dir = Path ( __file__ ) . parent . parent / \"templates\" / directory paths . append ( themes_dir / theme ) if self . fallback_theme != \"\" : paths . append ( themes_dir / self . fallback_theme ) self . env = Environment ( autoescape = True , loader = FileSystemLoader ( paths )) # type: ignore self . env . filters [ \"highlight\" ] = do_highlight self . env . filters [ \"any\" ] = do_any","title":"__init__()"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.BaseRenderer.render","text":"Render a template using provided data and configuration options. Parameters: Name Type Description Default data Any The collected data to render. required config dict The rendering options. required Returns: Type Description str The rendered template as HTML. Source code in mkdocstrings/handlers/__init__.py @abstractmethod def render ( self , data : Any , config : dict ) -> str : \"\"\" Render a template using provided data and configuration options. Arguments: data: The collected data to render. config: The rendering options. Returns: The rendered template as HTML. \"\"\" # noqa: DAR202 (excess return section)","title":"render()"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.BaseRenderer.update_env","text":"Update the Jinja environment. Parameters: Name Type Description Default md Markdown The Markdown instance. Useful to add functions able to convert Markdown into the environment filters. required config dict Configuration options for mkdocs and mkdocstrings , read from mkdocs.yml . See the source code of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary. required Source code in mkdocstrings/handlers/__init__.py def update_env ( self , md : Markdown , config : dict ) -> None : \"\"\" Update the Jinja environment. Arguments: md: The Markdown instance. Useful to add functions able to convert Markdown into the environment filters. config: Configuration options for `mkdocs` and `mkdocstrings`, read from `mkdocs.yml`. See the source code of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary. \"\"\" # Re-instantiate md: see https://github.com/tomchristie/mkautodoc/issues/14 md = Markdown ( extensions = config [ \"mdx\" ], extensions_configs = config [ \"mdx_configs\" ]) self . env . filters [ \"convert_markdown\" ] = lambda text : do_mark_safe ( md . convert ( text ))","title":"update_env()"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.CollectionError","text":"An exception raised when some collection of data failed.","title":"CollectionError"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.ThemeNotSupported","text":"An exception raised to tell a theme is not supported.","title":"ThemeNotSupported"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.do_any","text":"Check if at least one of the item in the sequence evaluates to true. The any builtin as a filter for Jinja templates. Parameters: Name Type Description Default seq Sequence An iterable object. required attribute str The attribute name to use on each object of the iterable. None Returns: Type Description bool A boolean telling if any object of the iterable evaluated to True. Source code in mkdocstrings/handlers/__init__.py def do_any ( seq : Sequence , attribute : str = None ) -> bool : \"\"\" Check if at least one of the item in the sequence evaluates to true. The `any` builtin as a filter for Jinja templates. Arguments: seq: An iterable object. attribute: The attribute name to use on each object of the iterable. Returns: A boolean telling if any object of the iterable evaluated to True. \"\"\" if attribute is None : return any ( seq ) return any ( _ [ attribute ] for _ in seq )","title":"do_any()"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.do_highlight","text":"Highlight a code-snippet. This function is used as a filter in Jinja templates. Parameters: Name Type Description Default src str The code to highlight. required guess_lang bool Whether to guess the language or not. False language str Explicitly tell what language to use for highlighting. None inline bool Whether to do inline highlighting. False dedent bool Whether to dedent the code before highlighting it or not. True line_nums bool Whether to add line numbers in the result. False line_start int The line number to start with. 1 Returns: Type Description str The highlighted code as HTML text, marked safe (not escaped for HTML). Source code in mkdocstrings/handlers/__init__.py def do_highlight ( src : str , guess_lang : bool = False , language : str = None , inline : bool = False , dedent : bool = True , line_nums : bool = False , line_start : int = 1 , ) -> str : \"\"\" Highlight a code-snippet. This function is used as a filter in Jinja templates. Arguments: src: The code to highlight. guess_lang: Whether to guess the language or not. language: Explicitly tell what language to use for highlighting. inline: Whether to do inline highlighting. dedent: Whether to dedent the code before highlighting it or not. line_nums: Whether to add line numbers in the result. line_start: The line number to start with. Returns: The highlighted code as HTML text, marked safe (not escaped for HTML). \"\"\" if dedent : src = textwrap . dedent ( src ) highlighter = Highlight ( use_pygments = True , guess_lang = guess_lang , linenums = line_nums ) result = highlighter . highlight ( src = src , language = language , linestart = line_start , inline = inline ) if inline : return do_mark_safe ( result . text ) return do_mark_safe ( result )","title":"do_highlight()"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.get_handler","text":"Get a handler thanks to its name. This function dynamically imports a module named \"mkdocstrings.handlers.NAME\", calls its get_handler method to get an instance of a handler, and caches it in dictionary. It means that during one run (for each reload when serving, or once when building), a handler is instantiated only once, and reused for each \"autodoc\" instruction asking for it. Parameters: Name Type Description Default name str The name of the handler. Really, it's the name of the Python module holding it. required theme str The name of the theme to use. required custom_templates Optional[str] Directory containing custom templates. None config Any Configuration passed to the handler. {} Returns: Type Description BaseHandler An instance of a subclass of [ BaseHandler ][mkdocstrings.handlers.BaseHandler], as instantiated by the get_handler method of the handler's module. Source code in mkdocstrings/handlers/__init__.py def get_handler ( name : str , theme : str , custom_templates : Optional [ str ] = None , ** config : Any , ) -> BaseHandler : \"\"\" Get a handler thanks to its name. This function dynamically imports a module named \"mkdocstrings.handlers.NAME\", calls its `get_handler` method to get an instance of a handler, and caches it in dictionary. It means that during one run (for each reload when serving, or once when building), a handler is instantiated only once, and reused for each \"autodoc\" instruction asking for it. Arguments: name: The name of the handler. Really, it's the name of the Python module holding it. theme: The name of the theme to use. custom_templates: Directory containing custom templates. config: Configuration passed to the handler. Returns: An instance of a subclass of [`BaseHandler`][mkdocstrings.handlers.BaseHandler], as instantiated by the `get_handler` method of the handler's module. \"\"\" if name not in handlers_cache : module = importlib . import_module ( f \"mkdocstrings.handlers. { name } \" ) handlers_cache [ name ] = module . get_handler ( theme , custom_templates , ** config ) # type: ignore return handlers_cache [ name ]","title":"get_handler()"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.teardown","text":"Teardown all cached handlers and clear the cache. Source code in mkdocstrings/handlers/__init__.py def teardown () -> None : \"\"\"Teardown all cached handlers and clear the cache.\"\"\" for handler in handlers_cache . values (): handler . collector . teardown () handlers_cache . clear ()","title":"teardown()"},{"location":"reference/handlers/python/","text":"\u00a4 This module implements a handler for the Python language. The handler collects data with pytkdocs . PythonCollector \u00a4 The class responsible for loading Jinja templates and rendering them. It defines some configuration options, implements the render method, and overrides the update_env method of the [ BaseRenderer class][mkdocstrings.handlers.BaseRenderer]. default_config: dict \u00a4 The default selection options. Option Type Description Default filters List[str] Filter members with regular expressions. [ \"!^_[^_]\" ] members Union[bool, List[str]] Explicitly select the object members. pytkdocs default: True If members is a list of names, filters are applied only on the members children (not the members themselves). If members is False , none are selected. If members is True or an empty list, filters are applied on all members and their children. Members affect only the first layer of objects, while filters affect the whole object-tree recursively. Every filters is run against every object name. An object can be un-selected by a filter and re-selected by the next one: \"!^_\" : exclude all objects starting with an underscore \"^__\" : but select all objects starting with two underscores Obviously one could use a single filter instead: \"!^_[^_]\" , which is the default. __init__ ( self , setup_commands = None ) special \u00a4 Initialize the object. When instantiating a Python collector, we open a subprocess in the background with subprocess.Popen . It will allow us to feed input to and read output from this subprocess, keeping it alive during the whole documentation generation. Spawning a new Python subprocess for each \"autodoc\" instruction would be too resource intensive, and would slow down mkdocstrings a lot. Parameters: Name Type Description Default setup_commands Optional[List[str]] A list of python commands as strings to be executed in the subprocess before pytkdocs . None Source code in mkdocstrings/handlers/python.py def __init__ ( self , setup_commands : Optional [ List [ str ]] = None ) -> None : \"\"\" Initialize the object. When instantiating a Python collector, we open a subprocess in the background with `subprocess.Popen`. It will allow us to feed input to and read output from this subprocess, keeping it alive during the whole documentation generation. Spawning a new Python subprocess for each \"autodoc\" instruction would be too resource intensive, and would slow down `mkdocstrings` a lot. Arguments: setup_commands: A list of python commands as strings to be executed in the subprocess before `pytkdocs`. \"\"\" log . debug ( \"mkdocstrings.handlers.python: Opening 'pytkdocs' subprocess\" ) env = os . environ . copy () env [ \"PYTHONUNBUFFERED\" ] = \"1\" if setup_commands : # prevent the Python interpreter or the setup commands # from writing to stdout as it would break pytkdocs output commands = [ \"import sys\" , \"from io import StringIO\" , \"from pytkdocs.cli import main as pytkdocs\" , \"sys.stdout = StringIO()\" , # redirect stdout to memory buffer * setup_commands , \"sys.stdout.flush()\" , \"sys.stdout = sys.__stdout__\" , # restore stdout \"pytkdocs(['--line-by-line'])\" , ] cmd = [ sys . executable , \"-c\" , \"; \" . join ( commands )] else : cmd = [ sys . executable , \"-m\" , \"pytkdocs\" , \"--line-by-line\" ] self . process = Popen ( # noqa: S603,S607 (we trust the input, and we don't want to use the absolute path) cmd , universal_newlines = True , stderr = PIPE , stdout = PIPE , stdin = PIPE , bufsize =- 1 , env = env , ) collect ( self , identifier , config ) \u00a4 Collect the documentation tree given an identifier and selection options. In this method, we feed one line of JSON to the standard input of the subprocess that was opened during instantiation of the collector. Then we read one line of JSON on its standard output. We load back the JSON text into a Python dictionary. If there is a decoding error, we log it as error and raise a CollectionError. If the dictionary contains an error key, we log it as error (with the optional traceback value), and raise a CollectionError. If the dictionary values for keys loading_errors and parsing_errors are not empty, we log them as warnings. Then we pick up the only object within the objects list (there's always only one, because we collect them one by one), rebuild it's categories lists (see [ rebuild_category_lists() ][mkdocstrings.handlers.python.rebuild_category_lists]), and return it. Parameters: Name Type Description Default identifier str The dotted-path of a Python object available in the Python path. required config dict Selection options, used to alter the data collection done by pytkdocs . required Exceptions: Type Description CollectionError When there was a problem collecting the object documentation. Returns: Type Description Any The collected object-tree. Source code in mkdocstrings/handlers/python.py def collect ( self , identifier : str , config : dict ) -> Any : \"\"\" Collect the documentation tree given an identifier and selection options. In this method, we feed one line of JSON to the standard input of the subprocess that was opened during instantiation of the collector. Then we read one line of JSON on its standard output. We load back the JSON text into a Python dictionary. If there is a decoding error, we log it as error and raise a CollectionError. If the dictionary contains an `error` key, we log it as error (with the optional `traceback` value), and raise a CollectionError. If the dictionary values for keys `loading_errors` and `parsing_errors` are not empty, we log them as warnings. Then we pick up the only object within the `objects` list (there's always only one, because we collect them one by one), rebuild it's categories lists (see [`rebuild_category_lists()`][mkdocstrings.handlers.python.rebuild_category_lists]), and return it. Arguments: identifier: The dotted-path of a Python object available in the Python path. config: Selection options, used to alter the data collection done by `pytkdocs`. Raises: CollectionError: When there was a problem collecting the object documentation. Returns: The collected object-tree. \"\"\" final_config = dict ( self . default_config ) final_config . update ( config ) log . debug ( \"mkdocstrings.handlers.python: Preparing input\" ) json_input = json . dumps ({ \"objects\" : [{ \"path\" : identifier , ** final_config }]}) log . debug ( \"mkdocstrings.handlers.python: Writing to process' stdin\" ) self . process . stdin . write ( json_input + \" \\n \" ) # type: ignore self . process . stdin . flush () # type: ignore log . debug ( \"mkdocstrings.handlers.python: Reading process' stdout\" ) stdout = self . process . stdout . readline () # type: ignore log . debug ( \"mkdocstrings.handlers.python: Loading JSON output as Python object\" ) try : result = json . loads ( stdout ) except json . decoder . JSONDecodeError as exception : log . error ( f \"mkdocstrings.handlers.python: Error while loading JSON: { stdout } \" ) raise CollectionError ( str ( exception )) from exception error = result . get ( \"error\" ) if error : message = f \"mkdocstrings.handlers.python: Collection failed: { error } \" if \"traceback\" in result : message += f \" \\n { result [ 'traceback' ] } \" log . error ( message ) raise CollectionError ( error ) for loading_error in result [ \"loading_errors\" ]: log . warning ( f \"mkdocstrings.handlers.python: { loading_error } \" ) for errors in result [ \"parsing_errors\" ] . values (): for parsing_error in errors : log . warning ( f \"mkdocstrings.handlers.python: { parsing_error } \" ) # We always collect only one object at a time result = result [ \"objects\" ][ 0 ] log . debug ( \"mkdocstrings.handlers.python: Rebuilding categories and children lists\" ) rebuild_category_lists ( result ) return result teardown ( self ) \u00a4 Terminate the opened subprocess, set it to None . Source code in mkdocstrings/handlers/python.py def teardown ( self ) -> None : \"\"\"Terminate the opened subprocess, set it to `None`.\"\"\" log . debug ( \"mkdocstrings.handlers.python: Tearing process down\" ) self . process . terminate () PythonHandler \u00a4 The Python handler class, nothing specific here. PythonRenderer \u00a4 The class responsible for loading Jinja templates and rendering them. It defines some configuration options, implements the render method, and overrides the update_env method of the [ BaseRenderer class][mkdocstrings.handlers.BaseRenderer]. Attributes: Name Type Description fallback_theme str The theme to fallback to. default_config dict The default rendering options, see [ default_config ][mkdocstrings.handlers.python.PythonRenderer.default_config]. default_config: dict \u00a4 The default rendering options. Option Type Description Default show_root_heading bool Show the heading of the object at the root of the documentation tree. False show_root_toc_entry bool If the root heading is not shown, at least add a ToC entry for it. True show_root_full_path bool Show the full Python path for the root object heading. True show_object_full_path bool Show the full Python path of every object. False show_root_members_full_path bool Show the full Python path of objects that are children of the root object (for example, classes in a module). When False, show_object_full_path overrides. False show_category_heading bool When grouped by categories, show a heading for each category. False show_if_no_docstring bool Show the object heading even if it has no docstring or children with docstrings. False show_source bool Show the source code of this object. True group_by_category bool Group the object's children by categories: attributes, classes, functions, methods, and modules. True heading_level int The initial heading level to use. 2 render ( self , data , config ) \u00a4 Render a template using provided data and configuration options. Parameters: Name Type Description Default data Any The collected data to render. required config dict The rendering options. required Returns: Type Description str The rendered template as HTML. Source code in mkdocstrings/handlers/python.py def render ( self , data : Any , config : dict ) -> str : # noqa: D102 (ignore missing docstring) final_config = dict ( self . default_config ) final_config . update ( config ) template = self . env . get_template ( f \" { data [ 'category' ] } .html\" ) # Heading level is a \"state\" variable, that will change at each step # of the rendering recursion. Therefore, it's easier to use it as a plain value # than as an item in a dictionary. heading_level = final_config . pop ( \"heading_level\" ) return template . render ( ** { \"config\" : final_config , data [ \"category\" ]: data , \"heading_level\" : heading_level , \"root\" : True }, ) update_env ( self , md , config ) \u00a4 Update the Jinja environment. Parameters: Name Type Description Default md Markdown The Markdown instance. Useful to add functions able to convert Markdown into the environment filters. required config dict Configuration options for mkdocs and mkdocstrings , read from mkdocs.yml . See the source code of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary. required Source code in mkdocstrings/handlers/python.py def update_env ( self , md : Markdown , config : dict ) -> None : # noqa: D102 (ignore missing docstring) super () . update_env ( md , config ) self . env . trim_blocks = True self . env . lstrip_blocks = True self . env . keep_trailing_newline = False get_handler ( theme , custom_templates = None , setup_commands = None , ** config ) \u00a4 Simply return an instance of PythonHandler . Parameters: Name Type Description Default theme str The theme to use when rendering contents. required custom_templates Optional[str] Directory containing custom templates. None setup_commands Optional[List[str]] A list of commands as strings to be executed in the subprocess before pytkdocs . None config Any Configuration passed to the handler. {} Returns: Type Description PythonHandler An instance of PythonHandler . Source code in mkdocstrings/handlers/python.py def get_handler ( theme : str , # noqa: W0613 (unused argument config) custom_templates : Optional [ str ] = None , setup_commands : Optional [ List [ str ]] = None , ** config : Any , ) -> PythonHandler : \"\"\" Simply return an instance of `PythonHandler`. Arguments: theme: The theme to use when rendering contents. custom_templates: Directory containing custom templates. setup_commands: A list of commands as strings to be executed in the subprocess before `pytkdocs`. config: Configuration passed to the handler. Returns: An instance of `PythonHandler`. \"\"\" return PythonHandler ( collector = PythonCollector ( setup_commands = setup_commands ), renderer = PythonRenderer ( \"python\" , theme , custom_templates ), ) rebuild_category_lists ( obj ) \u00a4 Recursively rebuild the category lists of a collected object. Since pytkdocs dumps JSON on standard output, it must serialize the object-tree and flatten it to reduce data duplication and avoid cycle-references. Indeed, each node of the object-tree has a children list, containing all children, and another list for each category of children: attributes , classes , functions , methods and modules . It replaces the values in category lists with only the paths of the objects. Here, we reconstruct these category lists by picking objects in the children list using their path. For each object, we recurse on every one of its children. Parameters: Name Type Description Default obj dict The collected object, loaded back from JSON into a Python dictionary. required Source code in mkdocstrings/handlers/python.py def rebuild_category_lists ( obj : dict ) -> None : \"\"\" Recursively rebuild the category lists of a collected object. Since `pytkdocs` dumps JSON on standard output, it must serialize the object-tree and flatten it to reduce data duplication and avoid cycle-references. Indeed, each node of the object-tree has a `children` list, containing all children, and another list for each category of children: `attributes`, `classes`, `functions`, `methods` and `modules`. It replaces the values in category lists with only the paths of the objects. Here, we reconstruct these category lists by picking objects in the `children` list using their path. For each object, we recurse on every one of its children. Arguments: obj: The collected object, loaded back from JSON into a Python dictionary. \"\"\" for category in ( \"attributes\" , \"classes\" , \"functions\" , \"methods\" , \"modules\" ): obj [ category ] = [ obj [ \"children\" ][ path ] for path in obj [ category ]] obj [ \"children\" ] = [ child for _ , child in obj [ \"children\" ] . items ()] for child in obj [ \"children\" ]: rebuild_category_lists ( child )","title":"python.py"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python","text":"This module implements a handler for the Python language. The handler collects data with pytkdocs .","title":"mkdocstrings.handlers.python"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.PythonCollector","text":"The class responsible for loading Jinja templates and rendering them. It defines some configuration options, implements the render method, and overrides the update_env method of the [ BaseRenderer class][mkdocstrings.handlers.BaseRenderer].","title":"PythonCollector"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.PythonCollector.default_config","text":"The default selection options. Option Type Description Default filters List[str] Filter members with regular expressions. [ \"!^_[^_]\" ] members Union[bool, List[str]] Explicitly select the object members. pytkdocs default: True If members is a list of names, filters are applied only on the members children (not the members themselves). If members is False , none are selected. If members is True or an empty list, filters are applied on all members and their children. Members affect only the first layer of objects, while filters affect the whole object-tree recursively. Every filters is run against every object name. An object can be un-selected by a filter and re-selected by the next one: \"!^_\" : exclude all objects starting with an underscore \"^__\" : but select all objects starting with two underscores Obviously one could use a single filter instead: \"!^_[^_]\" , which is the default.","title":"default_config"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.PythonCollector.__init__","text":"Initialize the object. When instantiating a Python collector, we open a subprocess in the background with subprocess.Popen . It will allow us to feed input to and read output from this subprocess, keeping it alive during the whole documentation generation. Spawning a new Python subprocess for each \"autodoc\" instruction would be too resource intensive, and would slow down mkdocstrings a lot. Parameters: Name Type Description Default setup_commands Optional[List[str]] A list of python commands as strings to be executed in the subprocess before pytkdocs . None Source code in mkdocstrings/handlers/python.py def __init__ ( self , setup_commands : Optional [ List [ str ]] = None ) -> None : \"\"\" Initialize the object. When instantiating a Python collector, we open a subprocess in the background with `subprocess.Popen`. It will allow us to feed input to and read output from this subprocess, keeping it alive during the whole documentation generation. Spawning a new Python subprocess for each \"autodoc\" instruction would be too resource intensive, and would slow down `mkdocstrings` a lot. Arguments: setup_commands: A list of python commands as strings to be executed in the subprocess before `pytkdocs`. \"\"\" log . debug ( \"mkdocstrings.handlers.python: Opening 'pytkdocs' subprocess\" ) env = os . environ . copy () env [ \"PYTHONUNBUFFERED\" ] = \"1\" if setup_commands : # prevent the Python interpreter or the setup commands # from writing to stdout as it would break pytkdocs output commands = [ \"import sys\" , \"from io import StringIO\" , \"from pytkdocs.cli import main as pytkdocs\" , \"sys.stdout = StringIO()\" , # redirect stdout to memory buffer * setup_commands , \"sys.stdout.flush()\" , \"sys.stdout = sys.__stdout__\" , # restore stdout \"pytkdocs(['--line-by-line'])\" , ] cmd = [ sys . executable , \"-c\" , \"; \" . join ( commands )] else : cmd = [ sys . executable , \"-m\" , \"pytkdocs\" , \"--line-by-line\" ] self . process = Popen ( # noqa: S603,S607 (we trust the input, and we don't want to use the absolute path) cmd , universal_newlines = True , stderr = PIPE , stdout = PIPE , stdin = PIPE , bufsize =- 1 , env = env , )","title":"__init__()"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.PythonCollector.collect","text":"Collect the documentation tree given an identifier and selection options. In this method, we feed one line of JSON to the standard input of the subprocess that was opened during instantiation of the collector. Then we read one line of JSON on its standard output. We load back the JSON text into a Python dictionary. If there is a decoding error, we log it as error and raise a CollectionError. If the dictionary contains an error key, we log it as error (with the optional traceback value), and raise a CollectionError. If the dictionary values for keys loading_errors and parsing_errors are not empty, we log them as warnings. Then we pick up the only object within the objects list (there's always only one, because we collect them one by one), rebuild it's categories lists (see [ rebuild_category_lists() ][mkdocstrings.handlers.python.rebuild_category_lists]), and return it. Parameters: Name Type Description Default identifier str The dotted-path of a Python object available in the Python path. required config dict Selection options, used to alter the data collection done by pytkdocs . required Exceptions: Type Description CollectionError When there was a problem collecting the object documentation. Returns: Type Description Any The collected object-tree. Source code in mkdocstrings/handlers/python.py def collect ( self , identifier : str , config : dict ) -> Any : \"\"\" Collect the documentation tree given an identifier and selection options. In this method, we feed one line of JSON to the standard input of the subprocess that was opened during instantiation of the collector. Then we read one line of JSON on its standard output. We load back the JSON text into a Python dictionary. If there is a decoding error, we log it as error and raise a CollectionError. If the dictionary contains an `error` key, we log it as error (with the optional `traceback` value), and raise a CollectionError. If the dictionary values for keys `loading_errors` and `parsing_errors` are not empty, we log them as warnings. Then we pick up the only object within the `objects` list (there's always only one, because we collect them one by one), rebuild it's categories lists (see [`rebuild_category_lists()`][mkdocstrings.handlers.python.rebuild_category_lists]), and return it. Arguments: identifier: The dotted-path of a Python object available in the Python path. config: Selection options, used to alter the data collection done by `pytkdocs`. Raises: CollectionError: When there was a problem collecting the object documentation. Returns: The collected object-tree. \"\"\" final_config = dict ( self . default_config ) final_config . update ( config ) log . debug ( \"mkdocstrings.handlers.python: Preparing input\" ) json_input = json . dumps ({ \"objects\" : [{ \"path\" : identifier , ** final_config }]}) log . debug ( \"mkdocstrings.handlers.python: Writing to process' stdin\" ) self . process . stdin . write ( json_input + \" \\n \" ) # type: ignore self . process . stdin . flush () # type: ignore log . debug ( \"mkdocstrings.handlers.python: Reading process' stdout\" ) stdout = self . process . stdout . readline () # type: ignore log . debug ( \"mkdocstrings.handlers.python: Loading JSON output as Python object\" ) try : result = json . loads ( stdout ) except json . decoder . JSONDecodeError as exception : log . error ( f \"mkdocstrings.handlers.python: Error while loading JSON: { stdout } \" ) raise CollectionError ( str ( exception )) from exception error = result . get ( \"error\" ) if error : message = f \"mkdocstrings.handlers.python: Collection failed: { error } \" if \"traceback\" in result : message += f \" \\n { result [ 'traceback' ] } \" log . error ( message ) raise CollectionError ( error ) for loading_error in result [ \"loading_errors\" ]: log . warning ( f \"mkdocstrings.handlers.python: { loading_error } \" ) for errors in result [ \"parsing_errors\" ] . values (): for parsing_error in errors : log . warning ( f \"mkdocstrings.handlers.python: { parsing_error } \" ) # We always collect only one object at a time result = result [ \"objects\" ][ 0 ] log . debug ( \"mkdocstrings.handlers.python: Rebuilding categories and children lists\" ) rebuild_category_lists ( result ) return result","title":"collect()"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.PythonCollector.teardown","text":"Terminate the opened subprocess, set it to None . Source code in mkdocstrings/handlers/python.py def teardown ( self ) -> None : \"\"\"Terminate the opened subprocess, set it to `None`.\"\"\" log . debug ( \"mkdocstrings.handlers.python: Tearing process down\" ) self . process . terminate ()","title":"teardown()"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.PythonHandler","text":"The Python handler class, nothing specific here.","title":"PythonHandler"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.PythonRenderer","text":"The class responsible for loading Jinja templates and rendering them. It defines some configuration options, implements the render method, and overrides the update_env method of the [ BaseRenderer class][mkdocstrings.handlers.BaseRenderer]. Attributes: Name Type Description fallback_theme str The theme to fallback to. default_config dict The default rendering options, see [ default_config ][mkdocstrings.handlers.python.PythonRenderer.default_config].","title":"PythonRenderer"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.PythonRenderer.default_config","text":"The default rendering options. Option Type Description Default show_root_heading bool Show the heading of the object at the root of the documentation tree. False show_root_toc_entry bool If the root heading is not shown, at least add a ToC entry for it. True show_root_full_path bool Show the full Python path for the root object heading. True show_object_full_path bool Show the full Python path of every object. False show_root_members_full_path bool Show the full Python path of objects that are children of the root object (for example, classes in a module). When False, show_object_full_path overrides. False show_category_heading bool When grouped by categories, show a heading for each category. False show_if_no_docstring bool Show the object heading even if it has no docstring or children with docstrings. False show_source bool Show the source code of this object. True group_by_category bool Group the object's children by categories: attributes, classes, functions, methods, and modules. True heading_level int The initial heading level to use. 2","title":"default_config"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.PythonRenderer.render","text":"Render a template using provided data and configuration options. Parameters: Name Type Description Default data Any The collected data to render. required config dict The rendering options. required Returns: Type Description str The rendered template as HTML. Source code in mkdocstrings/handlers/python.py def render ( self , data : Any , config : dict ) -> str : # noqa: D102 (ignore missing docstring) final_config = dict ( self . default_config ) final_config . update ( config ) template = self . env . get_template ( f \" { data [ 'category' ] } .html\" ) # Heading level is a \"state\" variable, that will change at each step # of the rendering recursion. Therefore, it's easier to use it as a plain value # than as an item in a dictionary. heading_level = final_config . pop ( \"heading_level\" ) return template . render ( ** { \"config\" : final_config , data [ \"category\" ]: data , \"heading_level\" : heading_level , \"root\" : True }, )","title":"render()"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.PythonRenderer.update_env","text":"Update the Jinja environment. Parameters: Name Type Description Default md Markdown The Markdown instance. Useful to add functions able to convert Markdown into the environment filters. required config dict Configuration options for mkdocs and mkdocstrings , read from mkdocs.yml . See the source code of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary. required Source code in mkdocstrings/handlers/python.py def update_env ( self , md : Markdown , config : dict ) -> None : # noqa: D102 (ignore missing docstring) super () . update_env ( md , config ) self . env . trim_blocks = True self . env . lstrip_blocks = True self . env . keep_trailing_newline = False","title":"update_env()"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.get_handler","text":"Simply return an instance of PythonHandler . Parameters: Name Type Description Default theme str The theme to use when rendering contents. required custom_templates Optional[str] Directory containing custom templates. None setup_commands Optional[List[str]] A list of commands as strings to be executed in the subprocess before pytkdocs . None config Any Configuration passed to the handler. {} Returns: Type Description PythonHandler An instance of PythonHandler . Source code in mkdocstrings/handlers/python.py def get_handler ( theme : str , # noqa: W0613 (unused argument config) custom_templates : Optional [ str ] = None , setup_commands : Optional [ List [ str ]] = None , ** config : Any , ) -> PythonHandler : \"\"\" Simply return an instance of `PythonHandler`. Arguments: theme: The theme to use when rendering contents. custom_templates: Directory containing custom templates. setup_commands: A list of commands as strings to be executed in the subprocess before `pytkdocs`. config: Configuration passed to the handler. Returns: An instance of `PythonHandler`. \"\"\" return PythonHandler ( collector = PythonCollector ( setup_commands = setup_commands ), renderer = PythonRenderer ( \"python\" , theme , custom_templates ), )","title":"get_handler()"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.rebuild_category_lists","text":"Recursively rebuild the category lists of a collected object. Since pytkdocs dumps JSON on standard output, it must serialize the object-tree and flatten it to reduce data duplication and avoid cycle-references. Indeed, each node of the object-tree has a children list, containing all children, and another list for each category of children: attributes , classes , functions , methods and modules . It replaces the values in category lists with only the paths of the objects. Here, we reconstruct these category lists by picking objects in the children list using their path. For each object, we recurse on every one of its children. Parameters: Name Type Description Default obj dict The collected object, loaded back from JSON into a Python dictionary. required Source code in mkdocstrings/handlers/python.py def rebuild_category_lists ( obj : dict ) -> None : \"\"\" Recursively rebuild the category lists of a collected object. Since `pytkdocs` dumps JSON on standard output, it must serialize the object-tree and flatten it to reduce data duplication and avoid cycle-references. Indeed, each node of the object-tree has a `children` list, containing all children, and another list for each category of children: `attributes`, `classes`, `functions`, `methods` and `modules`. It replaces the values in category lists with only the paths of the objects. Here, we reconstruct these category lists by picking objects in the `children` list using their path. For each object, we recurse on every one of its children. Arguments: obj: The collected object, loaded back from JSON into a Python dictionary. \"\"\" for category in ( \"attributes\" , \"classes\" , \"functions\" , \"methods\" , \"modules\" ): obj [ category ] = [ obj [ \"children\" ][ path ] for path in obj [ category ]] obj [ \"children\" ] = [ child for _ , child in obj [ \"children\" ] . items ()] for child in obj [ \"children\" ]: rebuild_category_lists ( child )","title":"rebuild_category_lists()"}]}